<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Modern C++ Explained</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="section-lines.css">
        <link rel="stylesheet" href="version-commit.css">

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Preface</a></li><li class="chapter-item expanded affix "><li class="part-title">Modern C++ Elements</li><li class="chapter-item expanded "><a href="primitive/index.html">Fundamental Data Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="primitive/IntTypes.html">Integer Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="primitive/IntTypes_longlong.html">Integer Type long long</a></li></ol></li><li class="chapter-item expanded "><a href="primitive/CharTypes.html">Character Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="primitive/CharTypes_CharSetsEncodings.html">Character Sets and Encodings</a></li><li class="chapter-item expanded "><a href="primitive/CharTypes_NewCharTypes.html">New Character Types</a></li><li class="chapter-item expanded "><a href="primitive/CharTypes_StringLiteralCat.html">Automatic String Literal Concatenation</a></li><li class="chapter-item expanded "><a href="primitive/CharTypes_LibrarySuppor.html">Library Support</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="namespace/index.html">Namespace</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="namespace/InlineNamespace.html">Inline Namespace</a></li><li class="chapter-item expanded "><a href="namespace/NewNestedNamespaceSyntax.html">New Nested Namespace Syntax</a></li><li class="chapter-item expanded "><a href="namespace/UnnamedNamespace.html">Unnamed Namespace</a></li><li class="chapter-item expanded "><a href="namespace/MergedNamespace.html">Merged Namespace</a></li><li class="chapter-item expanded "><a href="namespace/GlobalNamespace.html">Global Namespace</a></li></ol></li><li class="chapter-item expanded "><a href="compiletimeeval/index.html">Compile Time Evaluation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="compiletimeeval/VarAndFuncs.html">Variables and Functions</a></li><li class="chapter-item expanded "><a href="compiletimeeval/Constructors.html">Constructors</a></li><li class="chapter-item expanded "><a href="compiletimeeval/Lambdas.html">Lambdas</a></li><li class="chapter-item expanded "><a href="compiletimeeval/FunctionInlining.html">Function Inlining </a></li><li class="chapter-item expanded "><a href="compiletimeeval/ConditionalCompilation.html">Conditional Compilation </a></li><li class="chapter-item expanded "><a href="compiletimeeval/VirtualFunctions.html">Virtual Functions</a></li><li class="chapter-item expanded "><a href="compiletimeeval/TryCatch.html">try-catch </a></li><li class="chapter-item expanded "><a href="compiletimeeval/DefaultInit.html">Default Initialization </a></li><li class="chapter-item expanded "><a href="compiletimeeval/ConstEvalAndConstInit.html">consteval and constinit</a></li><li class="chapter-item expanded "><a href="compiletimeeval/StdIsConstant.html">std::is_constant_evaluated</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Meta-template Programming</li><li class="chapter-item expanded affix "><li class="part-title">Algorithms</li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Modern C++ Explained</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/wxinix/cpp-explained" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="preface"><a class="header" href="#preface">Preface</a></h1>
<h2 id="the-evolution-of-c-from-classical-to-modern"><a class="header" href="#the-evolution-of-c-from-classical-to-modern">The Evolution of C++: from classical to modern</a></h2>
<p>Since its inception as &quot;C with classes&quot;, C++ has experienced numerous significant revisions and improvements. The language is now standardized by ISO JTC1/SC22/WG21, a working group composed of C++ experts from various countries. The first standardized version of C++ was <code>ISO/IEC 14882:1998</code>, commonly known as <code>C++98</code>. The next edition, <code>ISO/IEC 14882:2003</code>, was a minor revision that addressed issues found in <code>C++98</code>.</p>
<p>The true revolution of C++ arrived with <code>ISO/IEC 14882:2011</code>, also known as <code>C++11</code> or <code>C++0x</code>. Officially released in 2011, it had been delayed longer than originally planned, leading developers to joke about the delay by dubbing it <code>C++0B</code>, with the hexadecimal B representing the release year. <code>C++11</code> is considered a watershed moment in the language's evolution, marking the transition from classical to modern C++. It introduced many important additions to both the core language and the standard library, including rvalue references/move semantics, auto type deduction, uniform initialization syntax using {} lists, lambdas, variadic templates, SFINAE rules, and various smart pointer classes, among other valuable features for crafting robust C++ programs.</p>
<p>A small extension to <code>C++11</code> was introduced in <code>ISO/IEC 14882:2014</code>. This was followed by another major revision <code>ISO/IEC 14882:2017</code>, which added notable features like <code>std::any</code>, <code>std::variant</code>, and <code>std::optional</code> classes to the standard library.</p>
<p><code>C++20</code>, i.e., <code>ISO/IEC 14882:2020</code> was officially published on 15 December 2020, representing the latest major revision. The most welcomed core language features of <code>C++20</code> include <code>concepts</code> for generic type constraints, <code>modules</code> for improved expression of program physical modules, and <code>coroutines</code> for non-preemptive multitasking. Among the many new standard library features, the ranges library is particularly exciting, as it enables functional programming with &quot;pipeable&quot; functions similar to <code>F#</code>, my favorite .NET language.</p>
<p>Given the impact and changes brought about by <code>C++11/14/17/20</code>, it's clear that pre-2011 C++ and post-2011 C++ are fundamentally different languages. This distinction is reflected in the terms &quot;Classical C++&quot; represented by <code>C++98</code> and &quot;Modern C++&quot; represented by <code>C++11</code> and later. Learning the reimagined modern C++ as a new language is necessary, whether it's approached with enthusiasm or apprehension.</p>
<p>C++ was designed with backward compatibility to C, allowing developers to use C-style programming constructs such as raw pointers, arrays, and null-terminated strings. As C++ has evolved, the focus has shifted towards reducing the reliance on C-style idioms and sticking to the &quot;zero overhead&quot; principle. Modern C++ is simpler, safer, more elegant, and retains its speed.</p>
<h2 id="who-this-book-is-for"><a class="header" href="#who-this-book-is-for">Who this book is for</a></h2>
<p>This book expects readers to have a basic knowledge of C++ and a genuine interest in evolving their skills in modern C++. Most chapters are beginner-friendly, while some need extra focus. Advanced meta-template programming topics may require multiple readings but can be skipped initially. Beginners should refer to other C++ books for fundamental guidance.</p>
<h2 id="what-this-book-covers"><a class="header" href="#what-this-book-covers">What this book covers</a></h2>
<p>This book focuses on helping readers understand the rationale behind new C++11 to C++20 features, discussing past C++ limitations, and examining how these features address and optimize those issues. Wherever necessary, it also explains how new features are implemented in compilers. Code samples are tested using GCC, Clang, and MSVC. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fundamental-data-types"><a class="header" href="#fundamental-data-types">Fundamental Data Types</a></h1>
<p>The fundamental types in C++ include integer types, character types, and floating-point types. These types are considered fundamental because they are built into the language itself and can be used to create more complex data structures and objects. Additionally, they are the building blocks for other C++ data types, such as arrays, structures, and classes.</p>
<p>The following table lists the type specifiers of the fundamental data types in C++.</p>
<div class="table-wrapper"><table><thead><tr><th>Character Types</th><th>Integer Types</th><th>Floating-Point Types</th></tr></thead><tbody>
<tr><td><code>char</code></td><td><code>bool</code></td><td><code>float</code></td></tr>
<tr><td><code>wchar_t</code></td><td><code>short</code></td><td><code>double</code></td></tr>
<tr><td><code>char16_t</code></td><td><code>int</code></td><td><code>long double</code></td></tr>
<tr><td><code>char32_t</code></td><td><code>long</code></td><td></td></tr>
<tr><td><code>char8_t</code></td><td><code>long long</code></td><td></td></tr>
<tr><td></td><td><code>unsigned short</code></td><td></td></tr>
<tr><td></td><td><code>unsigned int</code></td><td></td></tr>
<tr><td></td><td><code>unsigned long</code></td><td></td></tr>
<tr><td></td><td><code>unsigned long long</code></td><td></td></tr>
<tr><td></td><td><code>signed char</code></td><td></td></tr>
<tr><td></td><td><code>unsigned char</code></td><td></td></tr>
</tbody></table>
</div>
<h2 id="void"><a class="header" href="#void"><code>void</code></a></h2>
<p><code>void</code> is considered a fundamental type in C++. It represents the absence of a value and is used as a placeholder in function signatures and pointer declarations. It cannot be used to declare variables because it has no size or storage, but it is an important part of the C++ language and is often used in conjunction with other data types.</p>
<h2 id="bool"><a class="header" href="#bool"><code>bool</code></a></h2>
<p><code>bool</code> is considered an integer type in C++, but it is often treated as a separate category due to its Boolean semantics.</p>
<h2 id="signed-char-and-unsigned-char"><a class="header" href="#signed-char-and-unsigned-char"><code>signed char</code> and <code>unsigned char</code></a></h2>
<p>In C++, the <code>char</code> type is considered a distinct type that can be used to represent individual characters in text string. It is technically not considered an integer type, but does have an integer representation according to the ASCII or Unicode standard, which allows it to be used for integer calculations in some context.</p>
<p>When <code>signed</code> or <code>unsigned</code> is applied to <code>char</code>, it creates a type for small integers that can hold values between 0 and 255 (or -128 to 127 in the case of signed char).Therefore, <code>signed char</code> and <code>unsigned char</code> are both considered integer types.</p>
<p>Note that <code>char</code> is a distinct type from <code>signed char</code> and <code>unsigned char</code>, and it is not guaranteed to be signed or unsigned. The signedness of <code>char</code> is implementation-defined, and it can vary depending on the platform and the compiler.</p>
<h2 id="type-qualifiers-and-cv-correctness"><a class="header" href="#type-qualifiers-and-cv-correctness">Type qualifiers and cv-correctness</a></h2>
<p>Type specifiers can be combined with type qualifiers. In C++, there are two type qualifiers: <code>const</code> and <code>volatile</code>.</p>
<ul>
<li><code>const</code> indicates that a variable's value cannot be modified after it has been initialized.</li>
<li><code>volatile</code> indicates that a variable's value can be modified by external factors such as hardware or other processes. Sometimes, <code>volatile</code> is applied to a variable to prevent compiler optimization.</li>
</ul>
<p>CV-correctness is a programming concept in C++ that involves using the <code>const</code> and <code>volatile</code> type qualifiers to ensure that functions and data members behave correctly in the presence of <code>const</code> and <code>volatile</code> objects.</p>
<p>For example, a member function that does not modify the state of the object it operates on should be declared <code>const</code>. This ensures that the function can be called on <code>const</code> objects, and that it does not modify the state of the object.</p>
<pre><code class="language-cpp">class Example {
public:
    // Declared const because it does not modify the object state
    int getValue() const; 
private:
    int value_;
};

int Example::getValue() const {
    return value_;
}
</code></pre>
<p>A member variable can also be declared <code>const</code> if it should not be modified in any case:</p>
<pre><code class="language-cpp">class Example {
public:
    Example(int value) : value_(value) {}
    int getValue() const {
        // Cannot be modified because getValue is const
        return value_; 
    }
private:
    // Declared const to ensure it cannot be modified
    const int value_; 
};
</code></pre>
<p>The <code>volatile</code> qualifier can be applied to variables that can be changed by external factors, such as hardware or other processes. This ensures that the compiler does not optimize away accesses to the variable, which could cause incorrect behavior.</p>
<pre><code class="language-cpp">volatile int* ptr; // Pointer to a volatile int
</code></pre>
<p>Using CV-correctness can help prevent errors and improve code safety by ensuring that functions and data members behave correctly in the presence of const and volatile objects.</p>
<h2 id="mutable"><a class="header" href="#mutable"><code>mutable</code></a></h2>
<p>In C++, mutable is a type specifier that can be used to declare a non-static data member that can be modified even if the containing object is declared <code>const</code>. This is useful when the variable represents a cache or temporary value that does not affect the state of the object.</p>
<pre><code class="language-cpp">class Example {
public:
    int getValue() const {
        // Marked const, so it cannot modify any non-mutable members.
        // However, it can modify mutable members such as cachedValue_.
        if (cachedValue_ == 0) {
            cachedValue_ = someExpensiveCalculation();
        }
        return cachedValue_;
    }

private:
    // Declared mutable to allow modification even 
    // if Example object is const
    mutable int cachedValue_;
};
</code></pre>
<p>In this example, <code>cachedValue_</code> is declared as <code>mutable</code>, which allows it to be modified even if the containing object is declared <code>const</code>. The <code>getValue()</code> function is declared <code>const</code>, which means it cannot modify any non-mutable members of the Example object, but it can modify the <code>mutable</code> member <code>cachedValue_</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integer-types"><a class="header" href="#integer-types">Integer Types</a></h1>
<h2 id="common-integer-types"><a class="header" href="#common-integer-types">Common integer types</a></h2>
<p>C++ supports several integer types with varying sizes and ranges. Here is a list of the most commonly used integer types in C++, available since the earlier versions of the language. Note that <code>char</code> is treated as integer type here for practical reason, though technically it is not.</p>
<div class="table-wrapper"><table><thead><tr><th>Type name</th><th>Typical Size (in bytes)</th><th>Range</th></tr></thead><tbody>
<tr><td><code>bool</code></td><td>1</td><td>Boolean literal <code>true</code> or <code>false</code>, added in C++98</td></tr>
<tr><td><code>char</code></td><td>1</td><td>[-128, 127] or [0, 255] depending on signedness</td></tr>
<tr><td><code>short</code></td><td>2</td><td>[-32,768, 32,767]</td></tr>
<tr><td><code>int</code></td><td>4</td><td>[-2,147,483,648, 2,147,483,647]</td></tr>
<tr><td><code>long</code></td><td>4 or 8</td><td>[-2,147,483,648, 2,147,483,647] or [-9,223,372,036,854,775,808, 9,223,372,036,854,775,807] depending on platform</td></tr>
<tr><td><code>long long</code></td><td>8</td><td>[-9,223,372,036,854,775,808, 9,223,372,036,854,775,807]</td></tr>
<tr><td><code>unsigned char</code></td><td>1</td><td>[0, 255]</td></tr>
<tr><td><code>unsigned short</code></td><td>2</td><td>[0, 65,535]</td></tr>
<tr><td><code>unsigned int</code></td><td>4</td><td>[0, 4,294,967,295]</td></tr>
<tr><td><code>unsigned long</code></td><td>4 or 8</td><td>[0, 4,294,967,295] or [0, 18,446,744,073,709,551,615] depending on platform</td></tr>
<tr><td><code>unsigned long long</code></td><td>8</td><td>[0, 18,446,744,073,709,551,615]</td></tr>
</tbody></table>
</div>
<p>The C++ standard does not specify the minimum bytes for these integer types, except the following constraints:</p>
<pre><code class="language-cpp">sizeof(char)      == 1                  // Rule 1
sizeof(char)      &lt;= sizeof(short)      // Rule 2
sizeof(short)     &lt;= sizeof(int)        // Rule 3
sizeof(int)       &lt;= sizeof(long)       // Rule 4
sizeof(long)      &lt;= sizeof(long long)  // Rule 5
sizeof(char)      *  CHAR_BIT &gt;= 8      // Rule 6
sizeof(short)     *  CHAR_BIT &gt;= 16     // Rule 7
sizeof(int)       *  CHAR_BIT &gt;= 16     // Rule 8
sizeof(long)      *  CHAR_BIT &gt;= 32     // Rule 9
sizeof(long long) *  CHAR_BIT &gt;= 64     // Rule 10
</code></pre>
<p><code>CHAR_BIT</code> represents the number of bits in a char type. Although most modern architectures use 8 bits per byte, this is not always the case as some older machines may have used 7-bit bytes. Under Rule 4, C/C++ allows <code>long</code> and <code>int</code> to have the same size, but it must be at least 32 bits according to Rule 9.</p>
<h2 id="fixed-size-integer-types"><a class="header" href="#fixed-size-integer-types">Fixed size integer types</a></h2>
<p>The C++11 standard introduced new integer types such as <code>int8_t</code>, <code>int16_t</code>, <code>int32_t</code>, and <code>int64_t</code> with fixed sizes, as well as their unsigned counterparts, <code>uint8_t</code>, <code>uint16_t</code>, <code>uint32_t</code>, and <code>uint64_t</code>. These types are guaranteed to have the specified size and range on any conforming implementation. </p>
<p>The following table summarizes fixed size integer types - note that the <code>intN_t</code> and <code>uintN_t</code> types are guaranteed to have exactly <code>N</code> bits, where <code>N</code> is 8, 16, 32, or 64.</p>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Size (in bytes)</th><th>Range</th></tr></thead><tbody>
<tr><td><code>int8_t</code></td><td>1</td><td>[-128, 127]</td></tr>
<tr><td><code>uint8_t</code></td><td>1</td><td>[0, 255]</td></tr>
<tr><td><code>int16_t</code></td><td>2</td><td>[-32,768, 32,767]</td></tr>
<tr><td><code>uint16_t</code></td><td>2</td><td>[0, 65,535]</td></tr>
<tr><td><code>int32_t</code></td><td>4</td><td>[-2,147,483,648, 2,147,483,647]</td></tr>
<tr><td><code>uint32_t</code></td><td>4</td><td>[0, 4,294,967,295]</td></tr>
<tr><td><code>int64_t</code></td><td>8</td><td>[-9,223,372,036,854,775,808, 9,223,372,036,854,775,807]</td></tr>
<tr><td><code>uint64_t</code></td><td>8</td><td>[0, 18,446,744,073,709,551,615]</td></tr>
</tbody></table>
</div>
<h2 id="128-bit-integer-types"><a class="header" href="#128-bit-integer-types">128-bit integer types</a></h2>
<p>The C++ standard does not define a 128-bit integer type, as of the latest version C++20.</p>
<p>However, some compilers and libraries provide extensions that define a 128-bit integer type. For example, the GCC and Clang compilers provide an __int128 type, which is a 128-bit signed integer type. The Boost Multiprecision library provides several integer types with arbitrary precision, including a boost::multiprecision::int128_t type.</p>
<div class="table-wrapper"><table><thead><tr><th>Type name</th><th>Library/Compiler</th><th>Description</th></tr></thead><tbody>
<tr><td><code>__int128</code></td><td>GCC, Clang</td><td>A 128-bit signed integer type</td></tr>
<tr><td><code>unsigned __int128</code></td><td>GCC, Clang</td><td>A 128-bit unsigned integer type</td></tr>
<tr><td><code>int128_t</code></td><td>Boost Multiprecision</td><td>A 128-bit signed integer type</td></tr>
<tr><td><code>uint128_t</code></td><td>Boost Multiprecision</td><td>A 128-bit unsigned integer type</td></tr>
</tbody></table>
</div>
<p>It's important to note that the availability and behavior of non-standard integer types may vary depending on the platform and compiler used.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integer-type-long-long"><a class="header" href="#integer-type-long-long">Integer Type long long</a></h1>
<h2 id="history"><a class="header" href="#history">History</a></h2>
<p>Before <code>long long</code> was officially added to the C++11 standard in 2011, C++ programmers already knew about the <code>long long</code>  integer type for a long time. It has been part of the C language since the C99 standard, and many major C++ compilers supported <code>long long</code> for compatibility with C.</p>
<p>As early as 1995, Roland Hartinger first proposed to add <code>long long</code>  to C++. At the time, the C committee had not yet considered this type. As a result, the C++ committee was reluctant to add a fundamental type that was not also in C. After <code>long long</code> had been added to C99, Stephen Adamczyk proposed to reconsider its addition to C++ in 2005. Finally, <code>long long</code> was accepted as part of C++ in 2011, more than ten years after it was first included in the C standard.</p>
<h2 id="bit-size"><a class="header" href="#bit-size">Bit size</a></h2>
<p>The C++ standard defines <code>long long</code> as an integer type that is at least 64 bits long, but it does not guarantee that <code>long long</code> will always be 64 bits on all platforms. The size of <code>long long</code> can depend on the architecture and the compiler being used. However, most modern platforms do support a 64-bit <code>long long</code> type. To ensure portability and avoid any potential issues, it's best to use the <code>sizeof</code> operator to determine the size of <code>long long</code> on a specific platform.</p>
<p>Remember that in C++, <code>long long</code> is a signed data type, and its corresponding unsigned data type is <code>unsigned long long</code>. It's important to note that <code>long long int</code> and <code>unsigned long long int</code> have the same meaning as <code>long long</code> and <code>unsigned long long</code>, respectively, with the latter forms being shorthand for the former ones.</p>
<h2 id="literal-suffix"><a class="header" href="#literal-suffix">Literal suffix</a></h2>
<p>The C++ standard defines <code>LL</code> and <code>ULL</code> as literal suffixes for <code>long long</code> and <code>unsigned long long</code>, respectively. When initializing a <code>long long</code> type variable, you can write it like this:</p>
<pre><code class="language-cpp">long long x = 65536LL;
</code></pre>
<p>The literal suffix <code>LL</code> can be omitted with the same result:</p>
<pre><code class="language-cpp">long long x = 65536;
</code></pre>
<p>When working with large integer values in C++, it is important to use literal suffixes to ensure that the code runs as intended. For example:</p>
<pre><code class="language-cpp">long long x = 65536 &lt;&lt; 16; // Value overflows to 0
std::cout &lt;&lt; &quot;x = &quot; &lt;&lt; x &lt;&lt; std::endl;
long long y = 65536LL &lt;&lt; 16;
std::cout &lt;&lt; &quot;y = &quot; &lt;&lt; y &lt;&lt; std::endl;
</code></pre>
<p>The code <code>long long x = 65536 &lt;&lt; 16</code> performs a bitwise left shift operation on the decimal value 65536 by 16 bits, which can result in an overflow and unexpected behavior.</p>
<p>To prevent overflowing, we should use the <code>LL</code> literal suffix to ensure that the value is treated as a <code>long long</code> data type, as in <code>long long y = 65536LL &lt;&lt; 16</code>. This will ensure that the code runs as intended and the value is not unexpectedly truncated or overflowed.</p>
<h2 id="numerical-limits"><a class="header" href="#numerical-limits">Numerical limits</a></h2>
<p>We should avoid using <code>macro</code> as much as possible for defining the maximum and minimum values:</p>
<pre><code class="language-cpp">#define LLONG_MAX 9223372036854775807LL        // long long max value
#define LLONG_MIN (-9223372036854775807LL - 1) // long long min value
#define ULLONG_MAX 0xFFFFFFFFFFFFFFFFULL       // unsigned long long max value
</code></pre>
<p>Instead, we should use <code>std::numeric_limits</code>:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;limits&gt;
#include &lt;cstdio&gt;

int main(int argc, char *argv[])
{
    // Avoid these!
    std::cout &lt;&lt; &quot;LLONG_MAX = &quot;  
            &lt;&lt; LLONG_MAX  
            &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;LLONG_MIN = &quot;  
            &lt;&lt; LLONG_MIN  
            &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;ULLONG_MAX = &quot; 
            &lt;&lt; ULLONG_MAX 
            &lt;&lt; std::endl;

    std::printf(&quot;LLONG_MAX  = %lld\n&quot;, LLONG_MAX);  // format specifier %lld
    std::printf(&quot;LLONG_MIN  = %lld\n&quot;, LLONG_MIN);  // format specifier %lld
    std::printf(&quot;ULLONG_MAX = %llu\n&quot;, ULLONG_MAX); // format specifier %llu

    // Use std::numeric_limits
    std::cout &lt;&lt; &quot;std::numeric_limits&lt;long long&gt;::max() = &quot; 
            &lt;&lt; std::numeric_limits&lt;long long&gt;::max() 
            &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;std::numeric_limits&lt;long long&gt;::min() = &quot;
            &lt;&lt; std::numeric_limits&lt;long long&gt;::min()
            &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;std::numeric_limits&lt;unsigned long long&gt;::max() = &quot;
            &lt;&lt; std::numeric_limits&lt;unsigned long long&gt;::max() 
            &lt;&lt; std::endl;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="character-types"><a class="header" href="#character-types">Character Types</a></h1>
<p>In C++, <code>char</code> is not necessarily the same type as <code>signed char</code>, although on most platforms they are equivalent.</p>
<p>The C++ standard defines <code>char</code>, <code>signed char</code>, and <code>unsigned char</code> as three distinct integral types, each with its own range of representable values. The C++ standard does not specify whether <code>char</code> is <code>signed</code> or <code>unsigned</code> by default, which means that it is implementation-defined.</p>
<p>On most platforms, <code>char</code> is implemented as a signed type, and its range of representable values is the same as that of <code>signed char</code>. However, on some rare platforms, <code>char</code> may be implemented as an unsigned type, in which case it would have the same range of representable values as <code>unsigned char</code>.</p>
<p>So, while <code>char</code> and <code>signed char</code> are often the same type in C++, it is not guaranteed by the standard. To ensure portability of code that relies on the signedness of <code>char</code>, it is recommended to use <code>signed char</code> explicitly.</p>
<h2 id="issue-with-wchar_t"><a class="header" href="#issue-with-wchar_t">Issue with <code>wchar_t</code></a></h2>
<p><code>wchar_t</code> is a character type in C++ that is used to represent wide characters. It was introduced into C++ with the C++98 standard. Many Windows API functions have a wide character version that takes <code>wchar_t</code> strings as arguments. The wide character version of these functions has a suffix of <code>W</code> added to the function name. For example, the function <code>CreateFile()</code> in the Windows API has a wide character version named <code>CreateFileW()</code>. </p>
<p>The C++ standard specifies that a string literal with an <code>L</code> prefix creates a wide character string literal. </p>
<pre><code class="language-cpp">#include &lt;windows.h&gt;

int main()
{
    LPCWSTR fileName = L&quot;C:\\example\\test.txt&quot;;
    HANDLE hFile = CreateFileW(fileName, 
                               GENERIC_READ, 
                               FILE_SHARE_READ, 
                               NULL, 
                               OPEN_EXISTING, 
                               FILE_ATTRIBUTE_NORMAL, 
                               NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        // Handle error
        return 1;
    }
    // Do something with the file handle
    CloseHandle(hFile);
    return 0;
}

</code></pre>
<p>The issue with <code>wchar_t</code> is that its size is implementation-defined, which means that it can vary across different systems and compilers. The C++ standard does not specify the size of <code>wchar_t</code>, leaving it up to the implementation to decide. For example, on Windows systems, <code>wchar_t</code> is 16 bits (2 bytes), while on Unix-like systems, it is typically 32 bits (4 bytes).</p>
<p>This lack of standardization has led to portability issues when writing cross-platform code. Code that relies on <code>wchar_t</code> may not work as expected when compiled on a different system with a different <code>wchar_t</code> size. This can result in problems with data alignment, byte order, and other issues that can cause the program to behave incorrectly.</p>
<p>To address this issue, the C++11 standard introduced new character types, <code>char16_t</code> and <code>char32_t</code>, which have fixed sizes of 16 and 32 bits, respectively. These types are recommended for use in portable code, rather than <code>wchar_t</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="character-sets-and-encodings"><a class="header" href="#character-sets-and-encodings">Character Sets and Encodings</a></h1>
<h2 id="character-set"><a class="header" href="#character-set">Character set</a></h2>
<p>A character set, also known as a character repertoire, is a collection of characters and symbols that are used to represent written language in computing. Each character in a character set is assigned a unique code point, which is a numerical value that represents that character in digital form.</p>
<p>Character sets can include characters from many different writing systems and languages, such as the Latin alphabet used in English, or the Chinese characters used in Mandarin Chinese. Some character sets are designed for specific languages or scripts, while others are designed to be universal and include characters from many different languages.</p>
<p>Examples of character sets include ASCII, which includes characters commonly used in the English language, and Unicode, which is a universal character set that can represent all characters used in modern computing, including characters from many different writing systems.</p>
<h3 id="code-point"><a class="header" href="#code-point"><em>Code point</em></a></h3>
<p>A code point is a numerical value that represents a single character or symbol in a character set. Each character in a character set is assigned a unique code point, which is a specific number that identifies that character.</p>
<p>Code points are typically expressed as hexadecimal numbers, which means that they use a base-16 numbering system. For example, the code point for the letter &quot;A&quot; in the ASCII character set is 0x41, while the code point for the Greek letter &quot;α&quot; in the Unicode character set is 0x03B1.</p>
<p>Unicode comprises 1,114,112 code points in the range [0, 1,114,111]. The maximum value of Unicode code point is 1,114,111 (0x10FFFF).</p>
<h2 id="encodings"><a class="header" href="#encodings">Encodings</a></h2>
<p>Encoding involves mapping each code point to a specific sequence of bits or bytes that can be used to represent that character in digital form.</p>
<p>The Unicode standard defines a character set that includes 1,114,111 characters, each with a unique code point, and provides several encoding schemes, including UTF-8, UTF-16, and UTF-32, that allow characters to be represented using variable-length sequences of bytes.</p>
<h3 id="utf-8-encoding"><a class="header" href="#utf-8-encoding"><em>UTF-8 encoding</em></a></h3>
<p>UTF-8 is a variable-length encoding scheme. It works by mapping each Unicode code point to a sequence of 1 to 4 bytes, depending on the code point value. </p>
<div class="table-wrapper"><table><thead><tr><th>Code Point Range</th><th>Number of Bytes</th><th>Binary Format</th></tr></thead><tbody>
<tr><td>0 to 127</td><td>1 byte</td><td><code>0xxx'xxxx</code></td></tr>
<tr><td>128 to 2047</td><td>2 bytes</td><td><code>110x'xxxx, 10xx'xxxx</code></td></tr>
<tr><td>2048 to 65535</td><td>3 bytes</td><td><code>111'0xxxx 10x'xxxxx 10xx'xxxx</code></td></tr>
<tr><td>65536 to 1114111</td><td>4 bytes</td><td><code>1111'0xxx 10xx'xxxx 10xx'xxxx 10xx'xxxx</code></td></tr>
</tbody></table>
</div>
<p>Here's how UTF-8 encoding works:</p>
<ul>
<li>
<p>If the code point value is between 0 and 127 (inclusive), the code point is represented as a single byte with the same value. This means that ASCII characters (which have code point values between 0 and 127) can be represented in UTF-8 encoding using a single byte.</p>
</li>
<li>
<p>If the code point value is between 128 and 2047 (inclusive), the code point is represented as 2 bytes. The first byte starts with the binary value <code>110</code>, followed by 5 bits that represent the most significant bits of the code point value. The second byte starts with the binary value <code>10</code>, followed by 6 bits that represent the least significant bits of the code point value.</p>
</li>
<li>
<p>If the code point value is between 2048 and 65535 (inclusive), the code point is represented as 3 bytes. The first byte starts with the binary value <code>1110</code>, followed by 4 bits that represent the most significant bits of the code point value. The second and third bytes start with the binary value <code>10</code>, followed by 6 bits each that represent the remaining bits of the code point value.</p>
</li>
<li>
<p>If the code point value is between 65536 and 1114111 (inclusive), the code point is represented as 4 bytes. The first byte starts with the binary value <code>11110</code>, followed by 3 bits that represent the most significant bits of the code point value. The second, third, and fourth bytes start with the binary value <code>10</code>, followed by 6 bits each that represent the remaining bits of the code point value.</p>
</li>
</ul>
<p>By using a variable-length encoding scheme, UTF-8 encoding can represent all Unicode code points using a sequence of 1 to 4 bytes. This allows UTF-8 to be a compact and efficient encoding scheme. UTF-8 is a superset of ASCII and fully compatible with it.</p>
<p>UTF-8 has unique patterns with the first byte, and a fixed pattern with trailing bytes. This allows for easy validation of a correct UTF-8 sequence, quick &quot;scrolling&quot; to a random position and synchronizing quickly where a character will start.</p>
<h3 id="utf-16-encoding"><a class="header" href="#utf-16-encoding"><em>UTF-16 encoding</em></a></h3>
<div class="table-wrapper"><table><thead><tr><th>Code Point Range</th><th>Number of Bytes</th><th>Binary Format</th></tr></thead><tbody>
<tr><td>0 to 65535</td><td>1 code unit (2 bytes)</td><td><code>xxxxxxxx xxxxxxxx</code></td></tr>
<tr><td>65536 to 1114111</td><td>2 code units (4 bytes)</td><td><code>110110yy yyyyyyyy 110111xx xxxxxxxx</code></td></tr>
</tbody></table>
</div>
<ul>
<li>For code points in the range of 0 to 65535, UTF-16 encoding represents each code point using a single 16-bit code unit. </li>
<li>For code points in the range of 65536 to 1114111, UTF-16 encoding represents each code point using a pair of 16-bit code units, known as a surrogate pair. The first 16-bit code unit (known as the high surrogate) has a value in the range of 0xD800 to 0xDBFF, while the second 16-bit code unit (known as the low surrogate) has a value in the range of 0xDC00 to 0xDFFF.</li>
</ul>
<h3 id="utf-32-encoding"><a class="header" href="#utf-32-encoding"><em>UTF-32 encoding</em></a></h3>
<div class="table-wrapper"><table><thead><tr><th>Code Point Range</th><th>Number of Code Units</th><th>Binary Format</th></tr></thead><tbody>
<tr><td>0 to 1114111</td><td>1 code unit (4 bytes)</td><td><code>00000000 xxxxxxxx xxxxxxxx xxxxxxxx</code></td></tr>
</tbody></table>
</div>
<p>UTF-32 encoding represents each code point using a single 32-bit code unit, which means that every Unicode code point is represented using exactly 4 bytes of memory.</p>
<h3 id="why-not-utf-24-encoding"><a class="header" href="#why-not-utf-24-encoding"><em>Why not UTF-24 encoding</em></a></h3>
<p>Although it is theoretically possible to create a fixed-length encoding scheme using 3 bytes to represent each Unicode code point, such a scheme would not provide any significant advantages over existing ones like UTF-8, UTF-16, or UTF-32 in terms of processing or space efficiency. Many software systems and programming languages are optimized for these standard Unicode encoding schemes, making them more convenient and widely supported.</p>
<p>Furthermore, most of the commonly used Unicode code points are smaller than 65536, which means that using three bytes per code point would result in unnecessary wastage of space. Therefore, despite the theoretical possibility of a 3-byte fixed-length encoding scheme, it is not practical to use it in most real-world scenarios.</p>
<h3 id="byte-order-mark"><a class="header" href="#byte-order-mark"><em>Byte order mark</em></a></h3>
<p>The Unicode encoding of a text file can be determined by examining the byte order mark (BOM) at the beginning of the file, or by analyzing the byte sequences of the file.</p>
<div class="table-wrapper"><table><thead><tr><th>Encoding</th><th>Byte Order Mark</th></tr></thead><tbody>
<tr><td>UTF-8</td><td><code>EF BB BF</code> (optional)</td></tr>
<tr><td>UTF-16</td><td><code>FE FF</code> (big-endian) or <code>FF FE</code> (little-endian)</td></tr>
<tr><td>UTF-32</td><td><code>00 00 FE FF</code> (big-endian) or <code>FF FE 00 00</code> (little-endian)</td></tr>
</tbody></table>
</div>
<h2 id="code-page"><a class="header" href="#code-page">Code page</a></h2>
<p>The legacy term &quot;code page&quot; originated from IBM's EBCDIC-based mainframe systems. Originally, the code page numbers referred to the page numbers in the IBM standard character set manual.</p>
<p>Vendors that use a code page system allocate their own code page number to a character set and its encoding, even if it is better known by another name; for example, UTF-8 has been assigned page numbers 1208 at IBM, 65001 at Microsoft, and 4110 at SAP. </p>
<p>The following table lists Windows code pages used by Microsoft in its own Windows operating system.</p>
<div class="table-wrapper"><table><thead><tr><th>Microsoft Code Page</th><th>Code Page Number</th><th>Description</th></tr></thead><tbody>
<tr><td>Windows-1252</td><td>1252</td><td>Western European languages</td></tr>
<tr><td>Windows-1250</td><td>1250</td><td>Central and Eastern European languages</td></tr>
<tr><td>Windows-1251</td><td>1251</td><td>Cyrillic languages</td></tr>
<tr><td>Windows-1253</td><td>1253</td><td>Greek language</td></tr>
<tr><td>Windows-1254</td><td>1254</td><td>Turkish language</td></tr>
<tr><td>Windows-1255</td><td>1255</td><td>Hebrew language</td></tr>
<tr><td>Windows-1256</td><td>1256</td><td>Arabic language</td></tr>
<tr><td>Windows-1257</td><td>1257</td><td>Baltic languages</td></tr>
<tr><td>Windows-1258</td><td>1258</td><td>Vietnamese language</td></tr>
<tr><td>UTF-8</td><td>65001</td><td>8-bit Unicode</td></tr>
<tr><td>UTF-16LE</td><td>1200</td><td>16-bit Unicode, Little Endian</td></tr>
<tr><td>UTF-16BE</td><td>1201</td><td>16-bit Unicode, Big Endian</td></tr>
<tr><td>UTF-32LE</td><td>12000</td><td>32-bit Unicode, Little Endian</td></tr>
<tr><td>UTF-32BE</td><td>12001</td><td>32-bit Unicode, Big Endian</td></tr>
<tr><td>UTF-7</td><td>65000</td><td>7-bit Unicode</td></tr>
<tr><td>UTF-1</td><td>12000</td><td>8-bit Unicode</td></tr>
<tr><td>UTF-EBCDIC</td><td>1200</td><td>EBCDIC-based Unicode</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="new-character-types"><a class="header" href="#new-character-types">New Character Types</a></h1>
<h2 id="why-char-not-good-for-utf-8"><a class="header" href="#why-char-not-good-for-utf-8">Why <code>char</code> not good for UTF-8</a></h2>
<p>In C++, <code>char</code> is a fundamental type that represents a byte-sized unit of data. Historically, it has been used to represent both ASCII characters and other narrow character sets, depending on the execution environment. </p>
<p>Suppose we have the following C++ code (in C++11), with the source file saved as UTF-8 text:</p>
<pre><code class="language-cpp">// &quot;你吃饭了吗?&quot; literal is treated as a plain array of bytes, interpreted by
// the compiler as Windows-1252 single byte encoding.
const char* utf8_str = &quot;你吃饭了吗?&quot;; 
</code></pre>
<p>If the source file containing the Chinese characters &quot;你吃饭了吗?&quot; is saved as UTF-8 text, then the encoded representation of the text will also be in UTF-8 format. However, if the platform where the code is compiled is using a different encoding, such as Windows-1252, then the compiler may attempt to interpret the Chinese characters as single-byte characters in the Windows-1252 encoding, because the type of the variable <code>utf8_str</code> is declared as a plain <code>char</code> array, which relies on the execution environment to provide the encoding context. </p>
<p>For example, the Chinese character &quot;你&quot; is represented by three bytes in UTF-8, which are <code>0xE4 0xBD 0xA0</code>. When interpreted as Windows-1252, the first byte <code>0xE4</code> is an invalid character, so the compiler replaces it with the ASCII replacement character <code>0x3F</code>. As a result, every byte of the UTF-8 encoded string &quot;你吃饭了吗?&quot; is replaced with the ASCII replacement character <code>0x3F</code> before being assigned to <code>utf8_str</code>. The mismatched data can cause unexpected results and errors in the program. </p>
<h3 id="execution-environment-explained"><a class="header" href="#execution-environment-explained"><em>Execution environment explained</em></a></h3>
<p>The &quot;execution character set of the platform&quot; refers to the character encoding scheme used by the operating system and/or the compiler to represent text data internally in a computer program.</p>
<p>In C and C++, the execution character set determines how characters are represented in the char data type. The specific character set used can vary depending on the platform, compiler, and locale settings.</p>
<p>For example, on Windows systems, the default execution character set is typically based on the Windows-1252 code page, which is a superset of ASCII that includes characters for European languages. On Unix-based systems, the default execution character set is typically based on the ASCII encoding.</p>
<h2 id="utf-related-character-types"><a class="header" href="#utf-related-character-types">UTF-related character types</a></h2>
<p><code>char8_t</code> was introduced in C++20 to provide a distinct type that is guaranteed to represent an 8-bit code unit of UTF-8 encoded Unicode text. This allows for safer and more efficient handling of UTF-8 strings, as developers can use char8_t to represent individual code units of the UTF-8 encoding. This can help to avoid issues such as misinterpreting multi-byte sequences or incorrectly handling invalid code points. </p>
<p>In the following code, <code>utf8_str</code> will have the correct UTF-8 code point values, regardless of the execution character set of the platform.</p>
<pre><code class="language-cpp">// char8_t is a new C++20 type. The &quot;u8&quot; prefix makes sure the string literal is 
// interpreted as UTF-8 encoded text while enforcing type safety with char8_t.
// Without &quot;u8&quot; prefix, the string literal will be treated as &quot;const char*&quot; type,
// which is a type mismatch with char8_t, thus failing compiling.
const char8_t* utf8_str = u8&quot;你吃饭了吗?&quot;; 
// std::cout &lt;&lt; utf8_str &lt;&lt; std::endl; // This won't compile
</code></pre>
<blockquote>
<p>In C++20, there is no <code>char8_t</code>-aware I/O streams (the overloaded std::cout for <code>char8_t</code>, <code>char16_t</code> and <code>char32_t</code> are marked as &quot;delete&quot;. It is expected that the issue will be resolved in C++23 or C++26.</p>
</blockquote>
<p><code>char16_t</code> and <code>char32_t</code> were introduced in C++11 to provide support for Unicode text encoding. <code>char16_t</code> represents a 16-bit code unit of UTF-16 encoded Unicode text, while <code>char32_t</code> represents a 32-bit code unit of UTF-32 encoded Unicode text. </p>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Introduced in</th><th>Main Reason for Introduction</th><th>Literal Prefix</th><th>Sample Code</th></tr></thead><tbody>
<tr><td><code>char8_t</code></td><td>C++20</td><td>UTF-8 encoding</td><td><code>u8</code></td><td><code>const char8_t* str = u8&quot;吃了吗&quot;;</code></td></tr>
<tr><td><code>char16_t</code></td><td>C++11</td><td>UTF-16 encoding</td><td><code>u</code></td><td><code>const char16_t* str = u&quot;吃了吗&quot;;</code></td></tr>
<tr><td><code>char32_t</code></td><td>C++11</td><td>UTF-32 encoding</td><td><code>U</code></td><td><code>const char32_t* str = U&quot;吃了吗&quot;;</code></td></tr>
</tbody></table>
</div>
<p>The string literal prefix <code>u8</code>, <code>u</code>, <code>U</code> were introduced in C++11. The following code won't pass compilation with C++11 because they cannot be applied to characters. It is since C++17 that these literal prefix are allowed to be used with a character.</p>
<pre><code class="language-cpp">char utf8c = u8'a'; // C++11 will fail but C++17/20 can pass
</code></pre>
<p>Also the following code would fail compiling because the value cannot fit a single byte.</p>
<pre><code class="language-cpp">char utf8c = u8'好';
</code></pre>
<h2 id="print-utf-8-string-to-console"><a class="header" href="#print-utf-8-string-to-console">Print UTF-8 string to console</a></h2>
<p><code>std::cout</code> cannot be used to output UTF-8 string to console. Use <code>printf</code> instead. On Windows, remember to set the active code page of the Windows commandline console to UTF-8 by running <code>chcp</code> command first.</p>
<pre><code class="language-bash">chcp 65001
</code></pre>
<p>The following code uses <code>printf</code> to output an UTF-8 string.</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

// Remember to run Windows commandline command &quot;chcp 65001&quot; first to set the active
// code page to UTF-8.

int main() {
  // Null terminator automatically appended.
  char8_t utf8Chars[] = u8&quot;你好世界&quot;;
  // Will have two null terminators. 
  char8_t utf8CharsWithNull[] = u8&quot;你好世界\0&quot;; 

  auto len_1 = std::char_traits&lt;char8_t&gt;::length(utf8Chars);
  auto len_2 = std::char_traits&lt;char8_t&gt;::length(utf8CharsWithNull);

  cout &lt;&lt; &quot;length(utf8Chars) = &quot; 
       &lt;&lt; len_1 
       &lt;&lt; endl; // output 12

  cout &lt;&lt; &quot;length(utf8CharsWithNull) = &quot; 
       &lt;&lt; len_2 
       &lt;&lt; endl; // output 12

  cout &lt;&lt; &quot;sizeof(char8_t) = &quot; 
       &lt;&lt; sizeof(char8_t) 
       &lt;&lt; endl; // output 1
  
  // std::cout &lt;&lt; utf8Words &lt;&lt; std::endl; // This would fail compiling.  
  printf(&quot;%s&quot;, reinterpret_cast&lt;char*&gt;(&amp;utf8Chars[0]));

  /*
  for (std::size_t i = 0; i &lt; len; i++) {
    std::cout &lt;&lt; utf8Chars[i] &lt;&lt; '\n'; // This would fail compiling.
  }
  */

  return 0;
}

</code></pre>
<h2 id="print-a-character-of-utf-8-text-to-console"><a class="header" href="#print-a-character-of-utf-8-text-to-console">Print a character of UTF-8 text to console</a></h2>
<p>In C++20, the use of the <code>std::codecvt</code> facet is deprecated and discouraged. To display a UTF-8 string character on the Windows commandline console, we need to utilize the platform-specific <code>MultiByteToWideChar</code> function provided by Windows. This will convert the UTF-8 text to wide characters, which can then be output using <code>std::wcout</code>. If we need to access a particular character in the UTF-16 or UTF-32 text based on its position, we should apply the same approach.</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;locale&gt;
#include &lt;string&gt;
#include &lt;Windows.h&gt;

using namespace std;

// Remember to run Windows commandline command &quot;chcp 65001&quot; first to set the active
// code page to UTF-8.

int main() {
    u8string my_string = u8&quot;こんにちは&quot;;

    // my_string[0] is the byte value of the UTF-8 text at byte position 0.
    // The actual character could have multiple bytes.
    // std::cout &lt;&lt; my_string[0] &lt;&lt; std::endl; would fail compiling.

    // Get the required buffer size  
    int len = MultiByteToWideChar(CP_UTF8,
                                  0, 
                                  reinterpret_cast&lt;const char*&gt;(my_string.data()), 
                                  static_cast&lt;int&gt;(my_string.size()), 
                                  nullptr, 
                                  0);

    // Create a buffer of the required size
    wstring my_wstring(len, 0);

    // Convert to UTF-16 
    MultiByteToWideChar(CP_UTF8, 
                        0, 
                        reinterpret_cast&lt;const char*&gt;(my_string.data()), 
                        static_cast&lt;int&gt;(my_string.size()), 
                        &amp;my_wstring[0], 
                        len); 

    locale::global(locale(&quot;en_US.UTF-8&quot;));

    // Output the string
    wcout &lt;&lt; my_wstring &lt;&lt; endl; 

    for (int i = 0; i &lt; len; i++) {
       wcout &lt;&lt; my_wstring[i] &lt;&lt; endl;    
    }

    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="automatic-string-literal-concatenation"><a class="header" href="#automatic-string-literal-concatenation">Automatic String Literal Concatenation</a></h1>
<p>Automatic concatenation of adjacent string literals is a feature present in both C and C++ programming languages. It allows the compiler to automatically merge two or more string literals that are placed next to each other, without any explicit concatenation operator. This can be useful for breaking long strings into shorter, more manageable pieces, while still treating them as a single string constant.</p>
<p>Here is an example:</p>
<pre><code class="language-cpp">const char* my_string = &quot;Hello,&quot;
                        &quot;World!&quot;;
</code></pre>
<p>The compiler will automatically concatenate the two string literals, resulting in the following:</p>
<pre><code class="language-cpp">const char* my_string = &quot;Hello,World!&quot;;
</code></pre>
<blockquote>
<p>This feature has its roots in the C programming language. It was inherited by C++ in the early 1980s.</p>
</blockquote>
<h2 id="notes-on-automatic-string-literal-concatenation"><a class="header" href="#notes-on-automatic-string-literal-concatenation">Notes on automatic string literal concatenation</a></h2>
<p>Some nuances and caveats of using automatic concatenation of adjacent string literals:</p>
<h3 id="whitespace-not-strictly-required"><a class="header" href="#whitespace-not-strictly-required"><em>Whitespace not strictly required</em></a></h3>
<p>Adjacent string literals can be separated by whitespace, like a <code>space</code>, a <code>tab</code>, or a <code>newline</code>, for the concatenation to occur. However, white space between the literals is not strictly required, so the following is still valid in both C and C++:</p>
<pre><code class="language-cpp">const char* my_string = &quot;Hello,&quot;&quot;World&quot;;
</code></pre>
<p>The compile will automatically concatenate the adjacent string literals, resulting in the following:</p>
<pre><code class="language-cpp">const char* my_string = &quot;Hello,World&quot;;

</code></pre>
<blockquote>
<p>It's a good practice to include whitespace between adjacent string literals for better readability and maintainability.</p>
</blockquote>
<h3 id="compile-time-concatenation"><a class="header" href="#compile-time-concatenation"><em>Compile time concatenation</em></a></h3>
<p>The concatenation happens at compile-time, not at runtime, which means it has no performance overhead.</p>
<h3 id="variables-or-expressions-not-allowed"><a class="header" href="#variables-or-expressions-not-allowed"><em>Variables or expressions not allowed</em></a></h3>
<p>Automatic concatenation can only be used with string literals, not with variables or other expressions.</p>
<h3 id="mixed-encodings"><a class="header" href="#mixed-encodings"><em>Mixed encodings</em></a></h3>
<p>Be aware that trying to concatenate string literals with different character encodings may lead to compilation errors or unexpected behavior. For example, the following code will result in compiler error <em>&quot;concatenation of string literals with conflicting encoding prefixes&quot;</em>.</p>
<pre><code class="language-cpp">const char8_t* utf8Chars = u8&quot;Hello,&quot; 
                           L&quot;World!&quot;;
</code></pre>
<p>If one of the string literals does not have prefix, it will be treated as having the same as others, hence the following is a valid operation:</p>
<pre><code class="language-cpp">const char8_t* utf8Chars = u8&quot;Hello,&quot; 
                           &quot;World!&quot;; // Equivalent to u8&quot;World!&quot;
</code></pre>
<h2 id="the--operator"><a class="header" href="#the--operator">The <code>+</code> operator</a></h2>
<p>Using the + operator for concatenation works differently than automatic concatenation of adjacent string literals. In C++, the <code>+</code> operator can be used to concatenate <code>std::string</code> objects or a <code>std::string</code> object and a string literal. However, the <code>+</code> operator cannot be used to concatenate two string literals directly.</p>
<p>Here is an example:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
    std::string str1 = &quot;Hello, &quot;;
    std::string str2 = &quot;World!&quot;;
    
    std::string result = str1 + str2 + &quot;Oh Yeah&quot;; // Valid in C++
    
    std::cout &lt;&lt; result &lt;&lt; std::endl;
    return 0;
}
</code></pre>
<p>In the example above, the + operator is used to concatenate two std::string objects. However, trying to do this with string literals directly will lead to a compilation error:</p>
<pre><code class="language-cpp">const char* result = &quot;Hello, &quot; + &quot;World!&quot; + &quot;Oh Yeah; // NOT valid in C++ (or C)
</code></pre>
<p>C does not have the <code>std::string</code> class and the <code>+</code> operator for concatenation. Use functions like <code>strcat</code> or <code>strncat</code> from the <code>string.h</code> library to concatenate character arrays (null-terminated strings). Remember to allocate enough memory for the concatenated result and ensure that the destination string is null-terminated.</p>
<p>Here's an example of using strcat and strncat functions in C:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main() {
    char str1[20] = &quot;Hello, &quot;;
    char str2[] = &quot;world!&quot;;
    char str3[20] = &quot;I am a string.&quot;;

    // Using strcat
    strcat(str1, str2);
    printf(&quot;str1 after strcat: %s\n&quot;, str1);

    // Using strncat
    strncat(str3, str2, 4);
    printf(&quot;str3 after strncat: %s\n&quot;, str3);

    return 0;
}

</code></pre>
<p>In the above code, we have used two different functions for concatenating strings.</p>
<ul>
<li>
<p><code>strcat</code> function concatenates <code>str2</code> to the end of <code>str1</code> and modifies <code>str1</code>. After the <code>strcat</code> operation, <code>str1</code> will contain the concatenated string.</p>
</li>
<li>
<p><code>strncat</code> function concatenates a specified number of characters (in this case, 4) from  <code>str2</code> to the end of <code>str3</code> and modifies <code>str3</code>. After the strncat operation, <code>str3</code> will contain the concatenated string.</p>
</li>
</ul>
<p>The output of the above code will be:</p>
<pre><code class="language-c">str1 after strcat: Hello, world!
str3 after strncat: I am a string.worl
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="library-support"><a class="header" href="#library-support">Library Support</a></h1>
<h2 id="deprecated-library-support"><a class="header" href="#deprecated-library-support">Deprecated library support</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Component</th><th>Purpose</th><th>Status</th></tr></thead><tbody>
<tr><td><code>template&lt;class InternT, class ExternT, class StateT&gt; class codecvt</code> defined in header <code>&lt;locale&gt;</code></td><td>Provides a template class for converting between different character encodings</td><td>Deprecated in C++20</td></tr>
<tr><td><code>&lt;codecvt&gt;</code> header</td><td>Provides a set of templates for character encoding conversion, including <code>std::codecvt_utf8</code>, <code>std::codecvt_utf16</code>, and <code>std::codecvt_utf8_utf16</code></td><td>Deprecated in C++17</td></tr>
<tr><td><code>std::wstring_convert</code></td><td>Provides a higher-level interface for converting between wide character strings (<code>std::wstring</code>) and narrow character strings (<code>std::string</code>)</td><td>Deprecated in C++17</td></tr>
</tbody></table>
</div>
<h2 id="new-string-types"><a class="header" href="#new-string-types">New string types</a></h2>
<div class="table-wrapper"><table><thead><tr><th>String Type</th><th>Description</th><th>Basic Definition</th><th>Introduced in C++</th></tr></thead><tbody>
<tr><td>u8string</td><td>A string of 8-bit characters encoded in UTF-8</td><td><code>std::basic_string&lt;char8_t&gt;</code></td><td>C++20</td></tr>
<tr><td>u16string</td><td>A string of 16-bit characters encoded in UTF-16</td><td><code>std::basic_string&lt;char16_t&gt;</code></td><td>C++11</td></tr>
<tr><td>u32string</td><td>A string of 32-bit characters encoded in UTF-32</td><td><code>std::basic_string&lt;char32_t&gt;</code></td><td>C++11</td></tr>
</tbody></table>
</div>
<h2 id="stdpmru8string"><a class="header" href="#stdpmru8string"><code>std::pmr::u8string</code></a></h2>
<p><code>std::pmr::u8string</code> is a variant of the <code>std::basic_string</code> template that represents a sequence of 8-bit characters encoded in UTF-8 format, and allows for custom memory allocation using user-defined memory resources. It is part of the C++20 <em>Polymorphic Memory Resource</em> library (<code>std::pmr</code>).</p>
<p>To use <code>std::pmr::u8string</code>, you need to include the <code>&lt;string&gt;</code> and <code>&lt;memory_resource&gt;</code> headers, and create a <code>std::pmr::memory_resource</code> object to use as the memory allocator. You can then create an instance of <code>std::pmr::u8string</code> by passing the memory allocator as a constructor argument.</p>
<p>Here's an example of how to use <code>std::pmr::u8string</code>:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;memory_resource&gt;

int main()
{
    // create a memory pool using std::pmr::monotonic_buffer_resource
    std::pmr::monotonic_buffer_resource pool(1024);

    // create an std::pmr::u8string using the memory pool
    std::pmr::u8string str(u8&quot;Hello, world!&quot;, &amp;pool);

    // print the string to the console
    printf(reinterpret_cast&lt;char*&gt;(str.data()));

    return 0;
}
</code></pre>
<h2 id="c11-way"><a class="header" href="#c11-way">C11 way</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Function</th><th>Description</th></tr></thead><tbody>
<tr><td><code>mbrtoc16</code></td><td>Converts a multibyte sequence to a 16-bit wide character</td></tr>
<tr><td><code>c16rtomb</code></td><td>Converts a 16-bit wide character to a multibyte sequence</td></tr>
<tr><td><code>mbrtoc32</code></td><td>Converts a multibyte sequence to a 32-bit wide character</td></tr>
<tr><td><code>c32rtomb</code></td><td>Converts a 32-bit wide character to a multibyte sequence</td></tr>
</tbody></table>
</div>
<p>These are C11 functions. </p>
<blockquote>
<p>In the function name <code>mbrtoc16</code>, the &quot;rto&quot; stands for &quot;read to&quot;. This function reads a multibyte character sequence and converts it to a 16-bit wide character. The &quot;c16&quot; part of the function name indicates that the output is a 16-bit character, while the &quot;mb&quot; part indicates that the input is a multibyte character sequence.</p>
</blockquote>
<p>Here's an example of using the <code>mbrtoc16</code> function to convert a multibyte sequence to a 16-bit wide character:</p>
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;uchar.h&gt;
#include &lt;locale.h&gt;
#include &lt;wchar.h&gt;

int main() {
    setlocale(LC_ALL, &quot;en_US.UTF-8&quot;);

    char mbstr[] = &quot;Hello, world!&quot;; // Note char8_t is not part of C language yet.
    char16_t wc16;
    mbstate_t state = { 0 };
    size_t res = mbrtoc16(&amp;wc16, mbstr, sizeof(mbstr), &amp;state);
    if (res == (size_t)-1 || res == (size_t)-2) {
        printf(&quot;Error: invalid multibyte sequence\n&quot;);
        return 1;
    }
    printf(&quot;The first character is: %lc\n&quot;, (wint_t)wc16);

    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="namespace"><a class="header" href="#namespace">Namespace</a></h1>
<p>C++ namespaces provide a way to group related declarations and definitions, such as classes, functions, and variables, under a common name. This helps to avoid naming conflicts between different parts of a program or different libraries that may be used together.</p>
<p>Namespaces were introduced into the C++ standard with the release of C++98. The syntax for declaring and defining namespaces is similar to that used for classes. Here's an example:</p>
<pre><code class="language-cpp">// Declaration of a namespace
namespace MyNamespace {
    int x;
    void foo();
}

// Definition of the namespace's contents
namespace MyNamespace {
    int x = 42;
    void foo() {
        // Implementation of the function
    }
}
</code></pre>
<p>In this example, <code>MyNamespace</code> is declared and defined to contain an integer variable <code>x</code> and a function <code>foo()</code>. The namespace's contents can be accessed using the scope resolution operator <code>::</code>, like this:</p>
<pre><code class="language-cpp">int main() {
    MyNamespace::x = 10;
    MyNamespace::foo();
    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inline-namespace"><a class="header" href="#inline-namespace">Inline Namespace</a></h1>
<h2 id="what-is-inline-namespace"><a class="header" href="#what-is-inline-namespace">What is <code>inline namespace</code></a></h2>
<p>When a namespace is declared as <code>inline</code>, it means that its members are automatically injected into the enclosing parent namespace, as if they were defined directly in the parent namespace. This allows clients of the namespace to refer to its members without needing to qualify them with the namespace name.</p>
<p>For example, consider the following code:</p>
<pre><code class="language-cpp">namespace outer {
    inline namespace inner {
        void foo() {}
    }
}
</code></pre>
<p>Here, <code>inner</code> is an inline namespace that is declared within the <code>outer</code> namespace. This means that <code>foo()</code> can be accessed either as <code>outer::inner::foo()</code> or simply as <code>outer::foo()</code>.</p>
<h2 id="use-case"><a class="header" href="#use-case">Use case</a></h2>
<p>C++ <code>inline</code> namespaces were introduced in the C++11 standard to provide a mechanism for versioning and incremental updates of libraries, without breaking backward compatibility. </p>
<p>An <code>inline</code> namespace can be used to provide an updated version of a library's interface, while still allowing old code to use the previous version. By using an <code>inline</code> namespace, the new version of the library can be introduced without breaking the existing code that depends on the old version.</p>
<p>Here is an example of how an inline namespace can be used:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

/*
// Initial version of the library
namespace MyLib {
    void foo() {
        std::cout &lt;&lt; &quot;Hello, world!&quot; &lt;&lt; std::endl;
    }
}
*/

// Updated version of the library, in an inline namespace
namespace MyLib {
    inline namespace v1 {
        void foo() {
            std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;
        }
    }
    
    namespace v2 {
        void foo() {
            std::cout &lt;&lt; &quot;Hello, C++11!&quot; &lt;&lt; std::endl;
        }
    }
}

// Usage of the library
int main() {
    MyLib::foo();     // calls the initial version of foo
    MyLib::v2::foo(); // calls the updated version of foo
    return 0;
}
</code></pre>
<p>This code demonstrates how backward compatibility is maintained in a library called <code>MyLib</code>, which defines two versions of a function named <code>foo()</code>. The output of the program will be:</p>
<pre><code>Hello, World!
Hello, C++11!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="new-nested-namespace-syntax"><a class="header" href="#new-nested-namespace-syntax">New Nested Namespace Syntax</a></h1>
<p>Prior to C++17, nested namespaces are defined like this:</p>
<pre><code class="language-cpp">namespace A {
    namespace B {
        namespace C {
            int foo() { return 5; }
        }
    }
}
</code></pre>
<p>With C++17, the same nested namespaces can be defined using the inline syntax concisely:</p>
<pre><code class="language-cpp">namespace A::B::C {
    int foo() { return 5; }
}
</code></pre>
<p>Both of these code snippets achieve the same result: defining a function <code>foo()</code> in the namespace <code>A::B::C</code>. The inline namespace definition syntax introduced in C++17 allows for a more compact and readable way to define nested namespaces.</p>
<h2 id="nested-inline-namespace"><a class="header" href="#nested-inline-namespace">Nested inline namespace</a></h2>
<p>The combination of the nested namespace definition syntax (introduced in C++17) and the <code>inline</code> namespace declaration is allowed in C++20.</p>
<p>The following is valid in C++20:</p>
<pre><code class="language-cpp">namespace A::B::inline C {
    int foo() { return 5; }
}
</code></pre>
<p>In this code, the <code>inline</code> keyword is applied to the <code>C</code> namespace within the nested namespace definition <code>A::B</code>. This declares <code>C</code> as an inline namespace within the enclosing namespace <code>B</code>.</p>
<p>Note <code>inline</code> keyword can appear before any namespace name except namespace <code>A</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unnamed-namespace"><a class="header" href="#unnamed-namespace">Unnamed Namespace</a></h1>
<p>The <code>unnamed namespace</code> (or anonymous namespace) is a feature in C++ that was introduced in the C++98 standard. It provides a way to declare identifiers (e.g., functions, variables, or types) with internal linkage, meaning they are only visible within the scope of their parent namespace, or translation unit (i.e., the source file) in which they are defined.</p>
<p><code>Unnamed namespaces</code> can be declared using the <code>namespace</code> keyword, followed by a pair of braces, like this:</p>
<pre><code class="language-cpp">namespace {
    // Your code here
}
</code></pre>
<p>For example, a helper function or a constant that is only needed within a single source file, can be put in an unnamed namespace to prevent it from being accessible in other parts of the program:</p>
<pre><code class="language-cpp">// File: my_file.cpp
#include &quot;my_file.h&quot;

namespace {
    const int someConstant = 42;

    void helperFunction() {
        // Implementation here
    }
}

void myPublicFunction() {
    helperFunction();
    // Other implementation details
}
</code></pre>
<p>In this example, <code>someConstant</code> and <code>helperFunction</code> are only visible within <code>my_file.cpp</code> and won't conflict with any other code using the same names.</p>
<p>Another example:</p>
<pre><code class="language-cpp">namespace my_namespace {
    namespace {
        void helperFunction() {
            // Implementation here
        }
    }

    void publicFunction() {
        helperFunction(); // This is allowed since helperFunction() is in the same parent namespace
    }
}
</code></pre>
<p>In this example, <code>helperFunction()</code> is declared within an unnamed namespace inside <code>my_namespace</code>. Although <code>helperFunction()</code> has internal linkage and is not visible outside of the translation unit, it can still be accessed by other functions within the same parent namespace (<code>my_namespace</code>), such as <code>publicFunction()</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="merged-namespace"><a class="header" href="#merged-namespace">Merged Namespace</a></h1>
<p>If a namespace is defined multiple times, its contents are merged together. For example:</p>
<pre><code class="language-cpp">// First definition of namespace MyNamespace
namespace MyNamespace {
    int x = 1;
    void foo() {
        // Implementation of the function
    }
}

// Second definition of namespace MyNamespace, with different contents
namespace MyNamespace {
    int y = 2;
    void bar() {
        // Implementation of the function
    }
}

// Usage of the namespace contents
int main() {
    MyNamespace::foo();
    MyNamespace::bar();
    std::cout &lt;&lt; MyNamespace::x + MyNamespace::y &lt;&lt; std::endl;
    return 0;
}
</code></pre>
<p>Howerver, if the same variable is defined multiple times, a redefinition error will occur:</p>
<pre><code class="language-cpp">
#include &lt;iostream&gt;

namespace Namespace1 {
    int x = 1;
}

namespace Namespace1 {
    int x = 2;
}

int main() {
    std::cout &lt;&lt; Namespace1::x &lt;&lt; std::endl;
    std::cout &lt;&lt; Namespace2::x &lt;&lt; std::endl;
    return 0;
}


</code></pre>
<p>We'll see the following compiler error:</p>
<pre><code>&lt;source&gt;:8:9: error: redefinition of 'int Namespace1::x'
    8 |     int x = 2;
      |         ^
&lt;source&gt;:4:9: note: 'int Namespace1::x' previously defined here
    4 |     int x = 1;
      |         ^
&lt;source&gt;: In function 'int main()':
&lt;source&gt;:13:18: error: 'Namespace2' has not been declared
   13 |     std::cout &lt;&lt; Namespace2::x &lt;&lt; std::endl;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="global-namespace"><a class="header" href="#global-namespace">Global Namespace</a></h1>
<p>In C++, the global namespace is the outermost namespace that encompasses all the code in a program. When you define a variable, function, or type without explicitly placing it in a named or unnamed namespace, it becomes part of the global namespace. The global namespace is accessible from anywhere in the program, making its members visible across different translation units.</p>
<p>Although using the global namespace can make it easier to access identifiers without needing to specify a particular namespace, it is generally not recommended to place many identifiers in the global namespace, as it can lead to name clashes and reduced code maintainability. In large projects, putting too many identifiers in the global namespace can make it difficult to determine the purpose or origin of a particular identifier.</p>
<p>Instead, it's usually better to use named namespaces to organize and encapsulate your code, which helps prevent name collisions and improve code readability.</p>
<p>Here's an example that demonstrates the difference between global and named namespaces:</p>
<pre><code class="language-cpp">// Global namespace
int globalVariable = 10;

void globalFunction() {
    // Implementation here
}

// Named namespace
namespace my_namespace {
    int myVariable = 20;

    void myFunction() {
        // Implementation here
    }
}

int main() {
    globalFunction(); // Accessing a function in the global namespace
    my_namespace::myFunction(); // Accessing a function in a named namespace

    return 0;
}
</code></pre>
<p>In this example, <code>globalVariable</code> and <code>globalFunction()</code> are defined in the global namespace, while <code>myVariable</code> and <code>myFunction()</code> are defined within the named namespace <code>my_namespace</code>. To access members of a named namespace, use the namespace qualifier <code>::</code>.</p>
<h2 id="scope-resolution-operator-"><a class="header" href="#scope-resolution-operator-">Scope resolution operator <code>::</code></a></h2>
<p>The global namespace can be accessed explicitly by using the scope resolution operator <code>::</code>. This can be helpful when an identifier in the global namespace shares the same name as an identifier in a different namespace, or it is desirable to explicitly refer to the global namespace version of an identifier.</p>
<p>Here's an example demonstrating the use of <code>::</code> to access the global namespace:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

// Global namespace
int myVariable = 10;

namespace my_namespace {
    int myVariable = 20;

    void printVariables() {
        std::cout &lt;&lt; &quot;Global namespace myVariable: &quot; &lt;&lt; ::myVariable &lt;&lt; std::endl;
        std::cout &lt;&lt; &quot;my_namespace myVariable: &quot; &lt;&lt; myVariable &lt;&lt; std::endl;
    }
}

int main() {
    my_namespace::printVariables();
    return 0;
}
</code></pre>
<p>In this example, there are two variables with the same name <code>myVariable</code>, one in the global namespace and another in the named namespace <code>my_namespace</code>. Inside the <code>printVariables()</code> function, resolution operator <code>::</code> is specified to access the <code>myVariable</code> from the global namespace, while the unqualified <code>myVariable</code> refers to the one in the <code>my_namespace</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compile-time-evaluation"><a class="header" href="#compile-time-evaluation">Compile Time Evaluation</a></h1>
<p>In C++, compile-time evaluation refers to the ability to evaluate expressions and perform computations at compile-time, rather than at runtime. This can be achieved using keywords such as <code>constexpr</code>, <code>consteval</code>, and <code>constinit</code>.</p>
<div class="table-wrapper"><table><thead><tr><th>Keyword</th><th>Introduced in</th><th>Usage</th></tr></thead><tbody>
<tr><td><code>constinit</code></td><td>C++20</td><td>Defines objects that are guaranteed to be initialized with a constant expression.</td></tr>
<tr><td><code>constexpr</code></td><td>C++11</td><td>Indicates that a function or object can be evaluated at compile-time.</td></tr>
<tr><td><code>consteval</code></td><td>C++20</td><td>Similar to <code>constexpr</code>, but functions marked with <code>consteval</code> must be evaluated at compile-time.</td></tr>
</tbody></table>
</div>
<p>In addition to these keywords, C++ also includes several other features that enable compile-time evaluation, such as template metaprogramming and the <code>std::integral_constant</code> class template. These features allow for complex computations and logic to be performed at compile-time, leading to more efficient and optimized code.</p>
<h2 id="performance-boost-with-compile-time-evaluation"><a class="header" href="#performance-boost-with-compile-time-evaluation">Performance boost with compile time evaluation</a></h2>
<p>The ability to perform compile-time evaluation is an important part of the C++ language, as it enables developers to create more efficient and optimized code. The C++ standard includes a number of requirements and guidelines for how these features should be implemented and used. These guidelines help ensure that code that uses compile-time evaluation is portable and can be used across different platforms and architectures.</p>
<p>Compile-time evaluation can help performance in several ways:</p>
<ol>
<li>
<p>Reduce runtime overhead: When values or expressions are evaluated at compile time, the resulting code can be optimized by the compiler. This can reduce the amount of runtime overhead that would be incurred if the same calculations were performed at runtime.</p>
</li>
<li>
<p>Eliminate runtime errors: By evaluating values or expressions at compile time, potential runtime errors can be caught and eliminated before the program is even executed. This can help improve the stability and reliability of the program.</p>
</li>
<li>
<p>Enable constant propagation: When values are known at compile time, they can be propagated throughout the code as constants. This can eliminate unnecessary memory accesses and reduce the number of instructions that need to be executed, leading to faster program execution.</p>
</li>
<li>
<p>Allow for more aggressive optimization: By providing the compiler with information about values and expressions at compile time, the compiler can perform more aggressive optimizations, such as <code>loop unrolling</code>, instruction scheduling, and register allocation. These optimizations can improve program performance by reducing the number of instructions that need to be executed and by maximizing the use of hardware resources.</p>
</li>
</ol>
<h2 id="a-real-life-sample"><a class="header" href="#a-real-life-sample">A real-life sample</a></h2>
<p>The following shows a picture of NEMA-TS2 16-channel Malfunction Management Unit (MMU). Credit: <a href="https://www.flickr.com/photos/robklug/5617557645/">Rob Klug</a></p>
<p><img src="compiletimeeval/mmucard.jpg" alt="Image" /></p>
<blockquote>
<p>A Malfunction Management Unit (MMU) is a device utilized in the traffic signal control industry to detect conflicts that may arise when conflicting traffic flows are given right of way simultaneously. This is achieved through the use of a soldering board at the hardware level, which defines the compatibility of each pair of different channels. Essentially, each channel is physically connected to the signal head in the field through load switches, and the compatibility between the channels is relayed to the MMU through this hardware board.</p>
</blockquote>
<p>The following illustrates an application of C++ compile time evaluation approach. It is part of the open source C++ <a href="https://github.com/Caliper-Corporation/TsmAPIsExamples/tree/main/HILS/vtc">Virtual Traffic Cabinet Framework (VTC)</a>. VTC framework is developed using modern C++ 20.</p>
<p>The code provides O(1) complexity for returning the start position of a given channel. Note the template functions have zero runtime overhead, while all searching are done at compile time. Apart from the performance benefits, the implementation is concise and generic for any sizable current or future evoluation of MMU compatibility cards.</p>
<pre><code class="language-cpp">/*!
 * The size of channel compatibility set. For example, for Channel 1 of MMU16,
 * its compatibility set includes 1-2, 1-3, 1-4, ..., 1-16, thus the size is 15.
 * @tparam Channel - The given MMU chanel.
 * @tparam MaxChannel - Max number of channels the MMU supports.
 * @return The size of the compatibility set of the given channel.
 */
template&lt;size_t Channel, size_t MaxChannel&gt; requires ((Channel &gt;= 1) &amp;&amp; (Channel &lt;= MaxChannel))
constexpr size_t ChannelSegmentSize()
{
  return (MaxChannel - Channel);
}

/*!
 * The start position (0-based) for the given MMU channel in the fixed-size MMU channel compatibility byte array.
 * @tparam Channel - The given MMU channel.
 * @tparam MaxChannel - Max number of channels the MMU supports.
 * @return The start position (0-based) for the given MMU channel.
 * @remarks MMU channel compatibility is represented by a fixed-size byte array, for
 * MMU16, the byte array has 120 bytes. Each channel has a start position and total number of relevant
 * bytes in the stream describing the channel's compatibility.
 */
template&lt;size_t Channel, size_t MaxChannel = 16&gt; requires ((Channel &gt;= 1) &amp;&amp; (Channel &lt;= MaxChannel))
constexpr size_t ChannelSegmentStartPos()
{
  if constexpr (Channel == 1) {
    return 0;
  } else if constexpr (Channel == 2) {
    return ChannelSegmentSize&lt;1, MaxChannel&gt;();
  } else {
    return ChannelSegmentSize&lt;Channel - 1, MaxChannel&gt;() + ChannelSegmentStartPos&lt;Channel - 1&gt;();
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variables-and-functions"><a class="header" href="#variables-and-functions">Variables and Functions</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constructors"><a class="header" href="#constructors">Constructors</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lambdas"><a class="header" href="#lambdas">Lambdas</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="function-inlining"><a class="header" href="#function-inlining">Function Inlining</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conditional-compilation"><a class="header" href="#conditional-compilation">Conditional Compilation</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="virtual-functions"><a class="header" href="#virtual-functions">Virtual Functions</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="try-catch"><a class="header" href="#try-catch">try-catch</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="default-initialization"><a class="header" href="#default-initialization">Default Initialization</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="consteval-and-constinit"><a class="header" href="#consteval-and-constinit">consteval and constinit</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stdis_constant_evaluated"><a class="header" href="#stdis_constant_evaluated">std::is_constant_evaluated</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
