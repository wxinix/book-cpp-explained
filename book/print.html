<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Modern C++ Explained</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="section-lines.css">
        <link rel="stylesheet" href="version-commit.css">

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Preface</a></li><li class="chapter-item expanded affix "><li class="part-title">Modern C++ Elements</li><li class="chapter-item expanded "><a href="primitive/index.html">Fundamental Data Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="primitive/IntTypes.html">Integer Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="primitive/IntTypes_longlong.html">Integer Type long long</a></li></ol></li><li class="chapter-item expanded "><a href="primitive/CharTypes.html">Character Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="primitive/CharTypes_CharSetsEncodings.html">Character Sets and Encodings</a></li><li class="chapter-item expanded "><a href="primitive/CharTypes_NewCharTypes.html">New Character Types</a></li><li class="chapter-item expanded "><a href="primitive/CharTypes_StringLiteralCat.html">String Literal Concatenation</a></li><li class="chapter-item expanded "><a href="primitive/CharTypes_LibrarySuppor.html">Library Support</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="namespace/index.html">Namespace</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="namespace/InlineNamespace.html">Inline Namespace</a></li><li class="chapter-item expanded "><a href="namespace/NestedNamespace.html">Nested Namespace</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Meta-template Programming</li><li class="chapter-item expanded affix "><li class="part-title">Algorithms</li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Modern C++ Explained</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/wxinix/cpp-explained" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="preface"><a class="header" href="#preface">Preface</a></h1>
<h2 id="the-evolution-of-c-from-classical-to-modern"><a class="header" href="#the-evolution-of-c-from-classical-to-modern">The Evolution of C++: From Classical to Modern</a></h2>
<p>Since its inception as &quot;C with classes,&quot; the precursor to the C++ programming language, C++ has experienced numerous significant revisions and improvements. The language is now standardized by ISO JTC1/SC22/WG21, a working group composed of C++ experts from various countries. The first standardized version of C++ was ISO/IEC 14882:1998, commonly known as C++98. The next edition, ISO/IEC 14882:2003, was a minor revision that addressed issues found in C++98.</p>
<p>The true revolution of C++ arrived with ISO/IEC 14882:2011, also known as C++11 or C++0x. Officially released in 2011, it had been delayed longer than originally planned, leading developers to joke about the delay by dubbing it &quot;C++0B,&quot; with the hexadecimal B representing the release year. C++11 is considered a watershed moment in the language's evolution, marking the transition from classical to modern C++. It introduced many important additions to both the core language and the standard library, including rvalue references/move semantics, auto type deduction, uniform initialization syntax using {} lists, lambdas, variadic templates, SFINAE rules, and various smart pointer classes, among other valuable features for crafting robust C++ programs.</p>
<p>A small extension to C++11 was introduced in ISO/IEC 14882:2014. This was followed by another major revision, ISO/IEC 14882:2017, which added notable features like std::any, std::variant, and std::optional classes to the standard library.</p>
<p>C++20, i.e., ISO/IEC 14882:2020 was officially published on 15 December 2020, representing the latest major revision. The most welcomed core language features of C++20 include concepts for generic type constraints, modules for improved expression of program physical modules, and coroutines for non-preemptive multitasking. Among the many new standard library features, the ranges library is particularly exciting, as it enables functional programming with &quot;pipeable&quot; functions similar to F#, my favorite .NET language.</p>
<p>Given the impact and changes brought about by C++11/14/17/20, it's clear that pre-2011 C++ and post-2011 C++ are fundamentally different languages. This distinction is reflected in the terms &quot;Classical C++&quot; represented by C++98 and &quot;Modern C++&quot; represented by C++11 and later. Learning the reimagined modern C++ as a new language is necessary, whether it's approached with enthusiasm or apprehension.</p>
<p>C++ was originally designed to be backward compatible with C, allowing for C-style programming with raw pointers, arrays, null-terminated strings, and more. While these features offer performance benefits, they can also introduce bugs and complexity. The evolution of C++ has focused on reducing the need for C-style idioms, but they remain available when necessary. Modern C++ is simpler, safer, more elegant, and retains its speed.</p>
<h2 id="who-this-book-is-for"><a class="header" href="#who-this-book-is-for">Who this book is for</a></h2>
<p>This book, aimed at readers with basic C++ knowledge, explores new features in Modern C++. Most chapters are beginner-friendly, while some need extra focus. Advanced meta-template programming topics may require multiple readings but can be skipped initially. Beginners should refer to other C++ books for fundamental guidance.</p>
<h2 id="what-this-book-covers"><a class="header" href="#what-this-book-covers">What this book covers</a></h2>
<p>This book focuses on helping readers understand the rationale behind new C++11 to C++20 features, discussing past C++ limitations, and examining how these features address and optimize those issues. Wherever necessary, it also explains how new features are implemented in compilers. Code samples are tested using GCC, Clang, and MSVC. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fundamental-data-types"><a class="header" href="#fundamental-data-types">Fundamental Data Types</a></h1>
<p>The fundamental types in C++ include integer types, character types, and floating-point types. These types are considered fundamental because they are built into the language itself and can be used to create more complex data structures and objects. Additionally, they are the building blocks for other C++ data types, such as arrays, structures, and classes.</p>
<p>The following table lists the type specifiers of the fundamental data types in C++.</p>
<div class="table-wrapper"><table><thead><tr><th>Character Types</th><th>Integer Types</th><th>Floating-Point Types</th></tr></thead><tbody>
<tr><td><code>char</code></td><td><code>bool</code></td><td><code>float</code></td></tr>
<tr><td><code>wchar_t</code></td><td><code>short</code></td><td><code>double</code></td></tr>
<tr><td><code>char16_t</code></td><td><code>int</code></td><td><code>long double</code></td></tr>
<tr><td><code>char32_t</code></td><td><code>long</code></td><td></td></tr>
<tr><td><code>char8_t</code></td><td><code>long long</code></td><td></td></tr>
<tr><td></td><td><code>unsigned short</code></td><td></td></tr>
<tr><td></td><td><code>unsigned int</code></td><td></td></tr>
<tr><td></td><td><code>unsigned long</code></td><td></td></tr>
<tr><td></td><td><code>unsigned long long</code></td><td></td></tr>
<tr><td></td><td><code>signed char</code></td><td></td></tr>
<tr><td></td><td><code>unsigned char</code></td><td></td></tr>
</tbody></table>
</div>
<h2 id="void"><a class="header" href="#void"><code>void</code></a></h2>
<p><code>void</code> is considered a fundamental type in C++. It represents the absence of a value and is used as a placeholder in function signatures and pointer declarations. It cannot be used to declare variables because it has no size or storage, but it is an important part of the C++ language and is often used in conjunction with other data types.</p>
<h2 id="bool"><a class="header" href="#bool"><code>bool</code></a></h2>
<p><code>bool</code> is considered an integer type in C++, but it is often treated as a separate category due to its Boolean semantics.</p>
<h2 id="signed-char-and-unsigned-char"><a class="header" href="#signed-char-and-unsigned-char"><code>signed char</code> and <code>unsigned char</code></a></h2>
<p>In C++, the <code>char</code> type is considered a distinct type that can be used to represent individual characters in text string. It is technically not considered an integer type, but does have an integer representation according to the ASCII or Unicode standard, which allows it to be used for integer calculations in some context.</p>
<p>When <code>signed</code> or <code>unsigned</code> is applied to <code>char</code>, it creates a type for small integers that can hold values between 0 and 255 (or -128 to 127 in the case of signed char).Therefore, <code>signed char</code> and <code>unsigned char</code> are both considered integer types.</p>
<p>Note that <code>char</code> is a distinct type from <code>signed char</code> and <code>unsigned char</code>, and it is not guaranteed to be signed or unsigned. The signedness of <code>char</code> is implementation-defined, and it can vary depending on the platform and the compiler.</p>
<h2 id="type-qualifiers-and-cv-correctness"><a class="header" href="#type-qualifiers-and-cv-correctness">Type Qualifiers and CV-Correctness</a></h2>
<p>Type specifiers can be combined with type qualifiers. In C++, there are two type qualifiers: <code>const</code> and <code>volatile</code>.</p>
<ul>
<li><code>const</code> indicates that a variable's value cannot be modified after it has been initialized.</li>
<li><code>volatile</code> indicates that a variable's value can be modified by external factors such as hardware or other processes. Sometimes, <code>volatile</code> is applied to a variable to prevent compiler optimization.</li>
</ul>
<p>CV-correctness is a programming concept in C++ that involves using the <code>const</code> and <code>volatile</code> type qualifiers to ensure that functions and data members behave correctly in the presence of <code>const</code> and <code>volatile</code> objects.</p>
<p>For example, a member function that does not modify the state of the object it operates on should be declared <code>const</code>. This ensures that the function can be called on <code>const</code> objects, and that it does not modify the state of the object.</p>
<pre><code class="language-cpp">class Example {
public:
    // Declared const because it does not modify the object state
    int getValue() const; 
private:
    int value_;
};

int Example::getValue() const {
    return value_;
}
</code></pre>
<p>A member variable can also be declared <code>const</code> if it should not be modified in any case:</p>
<pre><code class="language-cpp">class Example {
public:
    Example(int value) : value_(value) {}
    int getValue() const {
        // Cannot be modified because getValue is const
        return value_; 
    }
private:
    // Declared const to ensure it cannot be modified
    const int value_; 
};
</code></pre>
<p>The <code>volatile</code> qualifier can be applied to variables that can be changed by external factors, such as hardware or other processes. This ensures that the compiler does not optimize away accesses to the variable, which could cause incorrect behavior.</p>
<pre><code class="language-cpp">volatile int* ptr; // Pointer to a volatile int
</code></pre>
<p>Using CV-correctness can help prevent errors and improve code safety by ensuring that functions and data members behave correctly in the presence of const and volatile objects.</p>
<h2 id="mutable"><a class="header" href="#mutable"><code>mutable</code></a></h2>
<p>In C++, mutable is a type specifier that can be used to declare a non-static data member that can be modified even if the containing object is declared <code>const</code>. This is useful when the variable represents a cache or temporary value that does not affect the state of the object.</p>
<pre><code class="language-cpp">class Example {
public:
    int getValue() const {
        // Marked const, so it cannot modify any non-mutable members.
        // However, it can modify mutable members such as cachedValue_.
        if (cachedValue_ == 0) {
            cachedValue_ = someExpensiveCalculation();
        }
        return cachedValue_;
    }

private:
    // Declared mutable to allow modification even 
    // if Example object is const
    mutable int cachedValue_;
};
</code></pre>
<p>In this example, <code>cachedValue_</code> is declared as <code>mutable</code>, which allows it to be modified even if the containing object is declared <code>const</code>. The <code>getValue()</code> function is declared <code>const</code>, which means it cannot modify any non-mutable members of the Example object, but it can modify the <code>mutable</code> member <code>cachedValue_</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integer-types"><a class="header" href="#integer-types">Integer Types</a></h1>
<h2 id="common-integer-types"><a class="header" href="#common-integer-types">Common Integer Types</a></h2>
<p>C++ supports several integer types with varying sizes and ranges. Here is a list of the most commonly used integer types in C++, available since the earlier versions of the language. Note that <code>char</code> is treated as integer type here for practical reason, though technically it is not.</p>
<div class="table-wrapper"><table><thead><tr><th>Type name</th><th>Typical Size (in bytes)</th><th>Range</th></tr></thead><tbody>
<tr><td><code>bool</code></td><td>1</td><td>Boolean literal <code>true</code> or <code>false</code>, added in C++98</td></tr>
<tr><td><code>char</code></td><td>1</td><td>[-128, 127] or [0, 255] depending on signedness</td></tr>
<tr><td><code>short</code></td><td>2</td><td>[-32,768, 32,767]</td></tr>
<tr><td><code>int</code></td><td>4</td><td>[-2,147,483,648, 2,147,483,647]</td></tr>
<tr><td><code>long</code></td><td>4 or 8</td><td>[-2,147,483,648, 2,147,483,647] or [-9,223,372,036,854,775,808, 9,223,372,036,854,775,807] depending on platform</td></tr>
<tr><td><code>long long</code></td><td>8</td><td>[-9,223,372,036,854,775,808, 9,223,372,036,854,775,807]</td></tr>
<tr><td><code>unsigned char</code></td><td>1</td><td>[0, 255]</td></tr>
<tr><td><code>unsigned short</code></td><td>2</td><td>[0, 65,535]</td></tr>
<tr><td><code>unsigned int</code></td><td>4</td><td>[0, 4,294,967,295]</td></tr>
<tr><td><code>unsigned long</code></td><td>4 or 8</td><td>[0, 4,294,967,295] or [0, 18,446,744,073,709,551,615] depending on platform</td></tr>
<tr><td><code>unsigned long long</code></td><td>8</td><td>[0, 18,446,744,073,709,551,615]</td></tr>
</tbody></table>
</div>
<p>The C++ standard does not specify the minimum bytes for these integer types, except the following constraints:</p>
<pre><code class="language-cpp">sizeof(char)      == 1                  // Rule 1
sizeof(char)      &lt;= sizeof(short)      // Rule 2
sizeof(short)     &lt;= sizeof(int)        // Rule 3
sizeof(int)       &lt;= sizeof(long)       // Rule 4
sizeof(long)      &lt;= sizeof(long long)  // Rule 5
sizeof(char)      *  CHAR_BIT &gt;= 8      // Rule 6
sizeof(short)     *  CHAR_BIT &gt;= 16     // Rule 7
sizeof(int)       *  CHAR_BIT &gt;= 16     // Rule 8
sizeof(long)      *  CHAR_BIT &gt;= 32     // Rule 9
sizeof(long long) *  CHAR_BIT &gt;= 64     // Rule 10
</code></pre>
<p><code>CHAR_BIT</code> represents the number of bits in a char type. Although most modern architectures use 8 bits per byte, this is not always the case as some older machines may have used 7-bit bytes. Under Rule 4, C/C++ allows <code>long</code> and <code>int</code> to have the same size, but it must be at least 32 bits according to Rule 9.</p>
<h2 id="fixed-size-integer-types"><a class="header" href="#fixed-size-integer-types">Fixed Size Integer Types</a></h2>
<p>The C++11 standard introduced new integer types such as <code>int8_t</code>, <code>int16_t</code>, <code>int32_t</code>, and <code>int64_t</code> with fixed sizes, as well as their unsigned counterparts, <code>uint8_t</code>, <code>uint16_t</code>, <code>uint32_t</code>, and <code>uint64_t</code>. These types are guaranteed to have the specified size and range on any conforming implementation. </p>
<p>The following table summarizing these fixed size integer types - note that the <code>intN_t</code> and <code>uintN_t</code> types are guaranteed to have exactly <code>N</code> bits, where <code>N</code> is 8, 16, 32, or 64.</p>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Size (in bytes)</th><th>Range</th></tr></thead><tbody>
<tr><td><code>int8_t</code></td><td>1</td><td>[-128, 127]</td></tr>
<tr><td><code>uint8_t</code></td><td>1</td><td>[0, 255]</td></tr>
<tr><td><code>int16_t</code></td><td>2</td><td>[-32,768, 32,767]</td></tr>
<tr><td><code>uint16_t</code></td><td>2</td><td>[0, 65,535]</td></tr>
<tr><td><code>int32_t</code></td><td>4</td><td>[-2,147,483,648, 2,147,483,647]</td></tr>
<tr><td><code>uint32_t</code></td><td>4</td><td>[0, 4,294,967,295]</td></tr>
<tr><td><code>int64_t</code></td><td>8</td><td>[-9,223,372,036,854,775,808, 9,223,372,036,854,775,807]</td></tr>
<tr><td><code>uint64_t</code></td><td>8</td><td>[0, 18,446,744,073,709,551,615]</td></tr>
</tbody></table>
</div>
<h2 id="128-bit-integer-types"><a class="header" href="#128-bit-integer-types">128-bit Integer Types</a></h2>
<p>The C++ standard does not define a 128-bit integer type, as of the latest version C++20.</p>
<p>However, some compilers and libraries provide extensions that define a 128-bit integer type. For example, the GCC and Clang compilers provide an __int128 type, which is a 128-bit signed integer type. The Boost Multiprecision library provides several integer types with arbitrary precision, including a boost::multiprecision::int128_t type.</p>
<div class="table-wrapper"><table><thead><tr><th>Type name</th><th>Library/Compiler</th><th>Description</th></tr></thead><tbody>
<tr><td><code>__int128</code></td><td>GCC, Clang</td><td>A 128-bit signed integer type</td></tr>
<tr><td><code>unsigned __int128</code></td><td>GCC, Clang</td><td>A 128-bit unsigned integer type</td></tr>
<tr><td><code>int128_t</code></td><td>Boost Multiprecision</td><td>A 128-bit signed integer type</td></tr>
<tr><td><code>uint128_t</code></td><td>Boost Multiprecision</td><td>A 128-bit unsigned integer type</td></tr>
</tbody></table>
</div>
<p>It's important to note that the availability and behavior of non-standard integer types may vary depending on the platform and compiler used.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integer-type-long-long"><a class="header" href="#integer-type-long-long">Integer Type long long</a></h1>
<h2 id="history"><a class="header" href="#history">History</a></h2>
<p>Before <code>long long</code> was officially added to the C++11 standard in 2011, C++ programmers already knew about the <code>long long</code>  integer type for a long time. It has been part of the C language since the C99 standard, and many major C++ compilers supported <code>long long</code> for compatibility with C.</p>
<p>As early as 1995, Roland Hartinger first proposed to add <code>long long</code>  to C++. At the time, the C committee had not yet considered this type. As a result, the C++ committee was reluctant to add a fundamental type that was not also in C. After <code>long long</code> had been added to C99, Stephen Adamczyk proposed to reconsider its addition to C++ in 2005. Finally, <code>long long</code> was accepted as part of C++ in 2011, more than ten years after it was first included in the C standard.</p>
<h2 id="bit-size"><a class="header" href="#bit-size">Bit Size</a></h2>
<p>The C++ standard defines <code>long long</code> as an integer type that is at least 64 bits long, but it does not guarantee that <code>long long</code> will always be 64 bits on all platforms. The size of <code>long long</code> can depend on the architecture and the compiler being used. However, most modern platforms do support a 64-bit <code>long long</code> type. To ensure portability and avoid any potential issues, it's best to use the <code>sizeof</code> operator to determine the size of <code>long long</code> on a specific platform.</p>
<p>Keep in mind, <code>long long</code> is a signed type in C++, and its corresponding unsigned type is <code>unsigned long long</code>. In practice, <code>long long int</code> and <code>unsigned long long int</code>  have the same meaning as <code>long long</code> and <code>unsigned long long</code>, respectively. </p>
<h2 id="literal-suffix"><a class="header" href="#literal-suffix">Literal Suffix</a></h2>
<p>The C++ standard defines <code>LL</code> and <code>ULL</code> as literal suffixes for <code>long long</code> and <code>unsigned long long</code>, respectively. When initializing a <code>long long</code> type variable, you can write it like this:</p>
<pre><code class="language-cpp">long long x = 65536LL;
</code></pre>
<p>The literal suffix <code>LL</code> can be omitted with the same result:</p>
<pre><code class="language-cpp">long long x = 65536;
</code></pre>
<p>When working with large integer values in C++, it is important to use literal suffixes to ensure that the code runs as intended. For example:</p>
<pre><code class="language-cpp">long long x = 65536 &lt;&lt; 16; // Value overflows to 0
std::cout &lt;&lt; &quot;x = &quot; &lt;&lt; x &lt;&lt; std::endl;
long long y = 65536LL &lt;&lt; 16;
std::cout &lt;&lt; &quot;y = &quot; &lt;&lt; y &lt;&lt; std::endl;
</code></pre>
<p>The code <code>long long x = 65536 &lt;&lt; 16</code> performs a bitwise left shift operation on the decimal value 65536 by 16 bits, which can result in an overflow and unexpected behavior.</p>
<p>To prevent overflowing, we should use the <code>LL</code> literal suffix to ensure that the value is treated as a <code>long long</code> data type, as in <code>long long y = 65536LL &lt;&lt; 16</code>. This will ensure that the code runs as intended and the value is not unexpectedly truncated or overflowed.</p>
<h2 id="numerical-limits"><a class="header" href="#numerical-limits">Numerical Limits</a></h2>
<p>We should avoid using <code>macro</code> as much as possible for defining the maximum and minimum values:</p>
<pre><code class="language-cpp">#define LLONG_MAX 9223372036854775807LL        // long long max value
#define LLONG_MIN (-9223372036854775807LL - 1) // long long min value
#define ULLONG_MAX 0xFFFFFFFFFFFFFFFFULL       // unsigned long long max value
</code></pre>
<p>Instead, we should use <code>std::numeric_limits</code>:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;limits&gt;
#include &lt;cstdio&gt;

int main(int argc, char *argv[])
{
    // Avoid these!
    std::cout &lt;&lt; &quot;LLONG_MAX = &quot;  
            &lt;&lt; LLONG_MAX  
            &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;LLONG_MIN = &quot;  
            &lt;&lt; LLONG_MIN  
            &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;ULLONG_MAX = &quot; 
            &lt;&lt; ULLONG_MAX 
            &lt;&lt; std::endl;

    std::printf(&quot;LLONG_MAX  = %lld\n&quot;, LLONG_MAX);  // format specifier %lld
    std::printf(&quot;LLONG_MIN  = %lld\n&quot;, LLONG_MIN);  // format specifier %lld
    std::printf(&quot;ULLONG_MAX = %llu\n&quot;, ULLONG_MAX); // format specifier %llu

    // Use std::numeric_limits
    std::cout &lt;&lt; &quot;std::numeric_limits&lt;long long&gt;::max() = &quot; 
            &lt;&lt; std::numeric_limits&lt;long long&gt;::max() 
            &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;std::numeric_limits&lt;long long&gt;::min() = &quot;
            &lt;&lt; std::numeric_limits&lt;long long&gt;::min()
            &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;std::numeric_limits&lt;unsigned long long&gt;::max() = &quot;
            &lt;&lt; std::numeric_limits&lt;unsigned long long&gt;::max() 
            &lt;&lt; std::endl;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="character-types"><a class="header" href="#character-types">Character Types</a></h1>
<p>In C++, <code>char</code> is not necessarily the same type as <code>signed char</code>, although on most platforms they are equivalent.</p>
<p>The C++ standard defines <code>char</code>, <code>signed char</code>, and <code>unsigned char</code> as three distinct integral types, each with its own range of representable values. The C++ standard does not specify whether <code>char</code> is <code>signed</code> or <code>unsigned</code> by default, which means that it is implementation-defined.</p>
<p>On most platforms, <code>char</code> is implemented as a signed type, and its range of representable values is the same as that of <code>signed char</code>. However, on some rare platforms, <code>char</code> may be implemented as an unsigned type, in which case it would have the same range of representable values as <code>unsigned char</code>.</p>
<p>So, while <code>char</code> and <code>signed char</code> are often the same type in C++, it is not guaranteed by the standard. To ensure portability of code that relies on the signedness of <code>char</code>, it is recommended to use <code>signed char</code> explicitly.</p>
<h2 id="issue-with-wchar_t"><a class="header" href="#issue-with-wchar_t">Issue with <code>wchar_t</code></a></h2>
<p><code>wchar_t</code> is a character type in C++ that is used to represent wide characters. It was introduced into C++ with the C++98 standard. Many Windows API functions have a wide character version that takes <code>wchar_</code>t strings as arguments. The wide character version of these functions has a suffix of <code>W</code> added to the function name. For example, the function <code>CreateFile()</code> in the Windows API has a wide character version named <code>CreateFileW()</code>. </p>
<p>The C++ standard specifies that a string literal with an <code>L</code> prefix creates a wide character string literal. </p>
<pre><code class="language-cpp">#include &lt;windows.h&gt;

int main()
{
    LPCWSTR fileName = L&quot;C:\\example\\test.txt&quot;;
    HANDLE hFile = CreateFileW(fileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        // Handle error
        return 1;
    }
    // Do something with the file handle
    CloseHandle(hFile);
    return 0;
}

</code></pre>
<p>The issue with <code>wchar_t</code> is that its size is implementation-defined, which means that it can vary across different systems and compilers. The C++ standard does not specify the size of <code>wchar_t</code>, leaving it up to the implementation to decide. For example, on Windows systems, <code>wchar_t</code> is 16 bits (2 bytes), while on Unix-like systems, it is typically 32 bits (4 bytes).</p>
<p>This lack of standardization has led to portability issues when writing cross-platform code. Code that relies on <code>wchar_t</code> may not work as expected when compiled on a different system with a different <code>wchar_t</code> size. This can result in problems with data alignment, byte order, and other issues that can cause the program to behave incorrectly.</p>
<p>To address this issue, the C++11 standard introduced new character types, <code>char16_t</code> and <code>char32_t</code>, which have fixed sizes of 16 and 32 bits, respectively. These types are recommended for use in portable code, rather than <code>wchar_t</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="character-sets-and-encodings"><a class="header" href="#character-sets-and-encodings">Character Sets and Encodings</a></h1>
<h2 id="character-set"><a class="header" href="#character-set">Character Set</a></h2>
<p>A character set, also known as a character repertoire, is a collection of characters and symbols that are used to represent written language in computing. Each character in a character set is assigned a unique code point, which is a numerical value that represents that character in digital form.</p>
<p>Character sets can include characters from many different writing systems and languages, such as the Latin alphabet used in English, the Cyrillic alphabet used in Russian, or the Chinese characters used in Mandarin Chinese. Some character sets are designed for specific languages or scripts, while others are designed to be universal and include characters from many different languages.</p>
<p>Examples of character sets include ASCII, which includes characters commonly used in the English language, and Unicode, which is a universal character set that can represent all characters used in modern computing, including characters from many different writing systems.</p>
<h3 id="code-point"><a class="header" href="#code-point"><em>Code Point</em></a></h3>
<p>A code point is a numerical value that represents a single character or symbol in a character set. Each character in a character set is assigned a unique code point, which is a specific number that identifies that character.</p>
<p>Code points are typically expressed as hexadecimal numbers, which means that they use a base-16 numbering system. For example, the code point for the letter &quot;A&quot; in the ASCII character set is 0x41, while the code point for the Greek letter alpha in the Unicode character set is 0x03B1.</p>
<p>Code points are used to represent characters in digital form and are used by various encoding schemes to represent characters as binary data. Encoding schemes such as UTF-8, UTF-16, and UTF-32 map each code point to a specific sequence of bytes, allowing characters to be stored and transmitted in a digital format.</p>
<p>Unicode comprises 1,114,112 code points in the range [0, 1,114,111].</p>
<h2 id="encodings"><a class="header" href="#encodings">Encodings</a></h2>
<p>Encoding involves mapping each code point (i.e., the numerical value that represents a character in a character set) to a specific sequence of bits or bytes that can be used to represent that character in digital form.</p>
<p>Different encoding schemes use different methods for mapping code points to binary sequences. For example, UTF-8 encoding uses a variable-length encoding scheme that can represent each Unicode code point using 1 to 4 bytes, depending on the code point value, while UTF-16 encoding uses a fixed-length encoding scheme that represents each Unicode code point using 2 bytes.</p>
<p>The goal of encoding is to allow characters and symbols to be represented in digital form, which is necessary for storing, transmitting, and processing text data using computer systems.</p>
<h3 id="utf-8-encoding"><a class="header" href="#utf-8-encoding"><em>UTF-8 Encoding</em></a></h3>
<p>UTF-8 is a variable-length encoding scheme used to represent Unicode characters as binary data. UTF-8 encoding works by mapping each Unicode code point to a sequence of 1 to 4 bytes, depending on the code point value. </p>
<div class="table-wrapper"><table><thead><tr><th>Code Point Range</th><th>Number of Bytes</th><th>Binary Format</th></tr></thead><tbody>
<tr><td>0 to 127</td><td>1 byte</td><td><code>0xxx'xxxx</code></td></tr>
<tr><td>128 to 2047</td><td>2 bytes</td><td><code>110x'xxxx, 10xx'xxxx</code></td></tr>
<tr><td>2048 to 65535</td><td>3 bytes</td><td><code>111'0xxxx 10x'xxxxx 10xx'xxxx</code></td></tr>
<tr><td>65536 to 1114111</td><td>4 bytes</td><td><code>1111'0xxx 10xx'xxxx 10xx'xxxx 10xx'xxxx</code></td></tr>
</tbody></table>
</div>
<p>Here's how UTF-8 encoding works:</p>
<ul>
<li>
<p>If the code point value is between 0 and 127 (inclusive), the code point is represented as a single byte with the same value. This means that ASCII characters (which have code point values between 0 and 127) are represented in UTF-8 encoding using a single byte.</p>
</li>
<li>
<p>If the code point value is between 128 and 2047 (inclusive), the code point is represented as 2 bytes. The first byte starts with the binary value <code>110</code>, followed by 5 bits that represent the most significant bits of the code point value. The second byte starts with the binary value <code>10</code>, followed by 6 bits that represent the least significant bits of the code point value.</p>
</li>
<li>
<p>If the code point value is between 2048 and 65535 (inclusive), the code point is represented as 3 bytes. The first byte starts with the binary value <code>1110</code>, followed by 4 bits that represent the most significant bits of the code point value. The second and third bytes start with the binary value <code>10</code>, followed by 6 bits each that represent the remaining bits of the code point value.</p>
</li>
<li>
<p>If the code point value is between 65536 and 1114111 (inclusive), the code point is represented as 4 bytes. The first byte starts with the binary value <code>11110</code>, followed by 3 bits that represent the most significant bits of the code point value. The second, third, and fourth bytes start with the binary value <code>10</code>, followed by 6 bits each that represent the remaining bits of the code point value.</p>
</li>
</ul>
<p>By using a variable-length encoding scheme, UTF-8 encoding can represent all Unicode code points using a sequence of 1 to 4 bytes. This allows UTF-8 to be a compact and efficient encoding scheme, while still supporting a wide range of characters and symbols from many different writing systems. </p>
<p>UTF-8 is compatible with ASCII. The advantage of UTF-8 is that the lead bytes are unique patterns, and trailing bytes are a unique pattern, which allows for easy validation of a correct UTF-8 sequence, quick &quot;scrolling&quot; to a random position and synchronizing quickly where a character will start.</p>
<h3 id="utf-16-encoding"><a class="header" href="#utf-16-encoding"><em>UTF-16 Encoding</em></a></h3>
<div class="table-wrapper"><table><thead><tr><th>Code Point Range</th><th>Number of Bytes</th><th>Binary Format</th></tr></thead><tbody>
<tr><td>0 to 65535</td><td>1 code unit (2 bytes)</td><td><code>xxxxxxxx xxxxxxxx</code></td></tr>
<tr><td>65536 to 1114111</td><td>2 code units (4 bytes)</td><td><code>110110yy yyyyyyyy 110111xx xxxxxxxx</code></td></tr>
</tbody></table>
</div>
<ul>
<li>For code points in the range of 0 to 65535, UTF-16 encoding represents each code point using a single 16-bit code unit. </li>
<li>For code points in the range of 65536 to 1114111, UTF-16 encoding represents each code point using a pair of 16-bit code units, known as a surrogate pair. The first 16-bit code unit (known as the high surrogate) has a value in the range of 0xD800 to 0xDBFF, while the second 16-bit code unit (known as the low surrogate) has a value in the range of 0xDC00 to 0xDFFF.</li>
</ul>
<h3 id="utf-32-encoding"><a class="header" href="#utf-32-encoding"><em>UTF-32 Encoding</em></a></h3>
<div class="table-wrapper"><table><thead><tr><th>Code Point Range</th><th>Number of Code Units</th><th>Binary Format</th></tr></thead><tbody>
<tr><td>0 to 1114111</td><td>1 code unit (4 bytes)</td><td><code>00000000 0000xxxx xxxxxxxx xxxxxxxx</code></td></tr>
</tbody></table>
</div>
<p>UTF-32 encoding represents each code point using a single 32-bit code unit, which means that every Unicode code point is represented using exactly 4 bytes of memory. The binary format for UTF-32 encoding uses the first 12 bits to store zeros, followed by 10 bits that represent the most significant bits of the code point value, and then 10 bits that represent the least significant bits of the code point value.</p>
<h3 id="why-not-utf-24-encoding"><a class="header" href="#why-not-utf-24-encoding"><em>Why Not UTF-24 Encoding</em></a></h3>
<p>UTF-24 is not an official Unicode encoding and is not widely used or supported. Three-byte encoding is not commonly used because it does not offer significant advantages over UTF-16 or UTF-32, which are the most widely used Unicode encodings.</p>
<p>While it is theoretically possible to use a fixed-length encoding scheme that uses 3 bytes to represent each Unicode code point, such as in UTF-24 (if it ever exists), this encoding scheme would not offer significant benefits over UTF-8, UTF-16, or UTF-32 in terms of processing or space efficiency. Many software systems and programming languages are optimized for UTF-8, UTF-16, or UTF-32. Additionally, the most commonly used Unicode code points are smaller than 65536, so the use of three bytes per code point would result in wasted space. </p>
<h3 id="byte-order-mark"><a class="header" href="#byte-order-mark"><em>Byte Order Mark</em></a></h3>
<p>The Unicode encoding of a text file can be determined by examining the byte order mark (BOM) at the beginning of the file, or by analyzing the byte sequences of the file.</p>
<div class="table-wrapper"><table><thead><tr><th>Encoding</th><th>Byte Order Mark</th></tr></thead><tbody>
<tr><td>UTF-8</td><td><code>EF BB BF</code> (optional)</td></tr>
<tr><td>UTF-16</td><td><code>FE FF</code> (big-endian) or <code>FF FE</code> (little-endian)</td></tr>
<tr><td>UTF-32</td><td><code>00 00 FE FF</code> (big-endian) or <code>FF FE 00 00</code> (little-endian)</td></tr>
</tbody></table>
</div>
<hr />
<p>The following table summarizes common charset and their respective encodings.</p>
<div class="table-wrapper"><table><thead><tr><th>Character Set</th><th>Description</th><th>Encodings</th></tr></thead><tbody>
<tr><td>ASCII</td><td>A 7-bit character set that includes characters commonly used in the English language, such as letters, numbers, and punctuation.</td><td>ASCII, various 8-bit and 16-bit extensions, including ISO 8859 and Unicode</td></tr>
<tr><td>ISO-8859</td><td>A series of 8-bit character sets that include characters used in different regions of the world, such as ISO-8859-1 for Western Europe and ISO-8859-5 for Cyrillic languages.</td><td>Various, depending on the specific ISO-8859 variant</td></tr>
<tr><td>EBCDIC</td><td>A family of character encodings used primarily on IBM mainframe systems.</td><td>Various, depending on the specific EBCDIC variant</td></tr>
<tr><td>JIS</td><td>A set of character sets used for Japanese text, including JIS X 0201 for single-byte characters and JIS X 0213 for multi-byte characters.</td><td>Shift JIS</td></tr>
<tr><td>GB2312</td><td>A character set used for simplified Chinese text.</td><td>GBK, GB18030</td></tr>
<tr><td>Unicode</td><td>A universal character set that can represent all characters used in modern computing, including characters from many different writing systems.</td><td>UTF-8, UTF-16, UTF-32</td></tr>
<tr><td>Big5</td><td>A character set used for traditional Chinese text.</td><td>Big5, Big5-HKSCS</td></tr>
<tr><td>KOI8</td><td>A series of character sets used for various Cyrillic-based languages.</td><td>KOI8-R, KOI8-U, KOI8-T</td></tr>
<tr><td>TIS-620</td><td>A character set used for the Thai language.</td><td>TIS-620-2533, ISO-8859-11, Windows-874</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="new-character-types"><a class="header" href="#new-character-types">New Character Types</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="string-literal-concatenation"><a class="header" href="#string-literal-concatenation">String Literal Concatenation</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="library-support"><a class="header" href="#library-support">Library Support</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="namespace"><a class="header" href="#namespace">Namespace</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inline-namespace"><a class="header" href="#inline-namespace">Inline Namespace</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nested-namespace"><a class="header" href="#nested-namespace">Nested Namespace</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
